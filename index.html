<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>RFCN BBALL Game Manager - Web</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
</head>
<body class="bg-gray-100">
  <div id="root" className="container mx-auto p-4">App failed to load. Check console for errors.</div>
  <script type="text/javascript">
    // Version: 1.0.19 - 2025-06-29 - Fixed Start Fresh Game on Court A in 4x4 mode to only refresh Court A, not both courts
    // Version: 1.0.18 - 2025-06-29 - Fixed syntax error in startFirstGame for 4x4 mode Court A (8-15 players)
    // Version: 1.0.17 - 2025-06-29 - Changed "Leader Board:" to "Leader Board Wins:" in Player Stats; added new lines for team references in confirmation messages
    // Version: 1.0.16 - 2025-06-29 - Modified Start Next Game confirmation: max wins note on new line, red text, "Note" bolded and underscored
    // Version: 1.0.15 - 2025-06-29 - Changed "Max Wins" to "Leader Board" in Player Stats UI
    // Version: 1.0.14 - 2025-06-29 - Restored player names in win, start next, and start first/fresh game confirmation messages; added max wins warning to start next game
    // Version: 1.0.13 - 2025-06-29 - Fixed 'not enough players' error in 4x4 mode after second Start Fresh Game by relaxing player count checks and ensuring waitlist/nextTeam repopulation
    // Version: 1.0.12 - 2025-06-29 - Fixed players not appearing in waitlist/nextTeam and excessive localStorage logging
    // Version: 1.0.11 - 2025-06-29 - Fixed players not appearing in waitlist/nextTeam by calling fillNextTeam in addPlayer and simplifying useEffect
    // Version: 1.0.10 - 2025-06-29 - Fixed 'Cannot start game on A' alert by allowing startFirstGame when postMaxOutA is true in 5x5 mode
    // Version: 1.0.9 - 2025-06-28 - Fixed 'Cannot access startFirstGame before initialization' by reordering function declarations
    // Version: 1.0.8 - 2025-06-28 - Enabled Start First Game post-max-out with confirmation modal, renamed to Start Fresh Game, and added button exclusivity
    // Version: 1.0.7 - 2025-06-28 - Added "How We Play Around Here" section with initial game rules
    // Version: 1.0.6 - 2025-06-28 - Added 15-character limit for player names in signup
    // Version: 1.0.5 - 2025-06-28 - Fixed runtime error 'Cannot access startNextGame before initialization' by reordering function declarations
    // Version: 1.0.4 - 2025-06-28 - Added confirmation modal for Start Next Game with Next Team players, winning team, and max wins note
    // Version: 1.0.3 - 2025-06-28 - Added team players to winner confirmation modal message
    // Version: 1.0.2 - 2025-06-28 - Fixed syntax error causing 'Unexpected end of input'
    // Version: 1.0.1 - 2025-06-28 - Added confirmation modal for winner selection
    // Version: 1.0.0 - 2025-06-27 - Initial version with button50 fixed to button in Court B section
    const App = React.memo(() => {
      const [players, setPlayers] = React.useState([]);
      const [waitlist, setWaitlist] = React.useState([]);
      const [pausedList, setPausedList] = React.useState([]);
      const [nextTeam, setNextTeam] = React.useState([]);
      const [team1, setTeam1] = React.useState([]);
      const [team2, setTeam2] = React.useState([]);
      const [team3, setTeam3] = React.useState([]);
      const [team4, setTeam4] = React.useState([]);
      const [team1Wins, setTeam1Wins] = React.useState(0);
      const [team3Wins, setTeam3Wins] = React.useState(0);
      const [gameStartedA, setGameStartedA] = React.useState(false);
      const [gameStartedB, setGameStartedB] = React.useState(false);
      const [postMaxOutA, setPostMaxOutA] = React.useState(false);
      const [postMaxOutB, setPostMaxOutB] = React.useState(false);
      const [team1Label, setTeam1Label] = React.useState("Team 1");
      const [team2Label, setTeam2Label] = React.useState("Team 2");
      const [team3Label, setTeam3Label] = React.useState("Team 3");
      const [team4Label, setTeam4Label] = React.useState("Team 4");
      const [playerName, setPlayerName] = React.useState("");
      const [signupError, setSignupError] = React.useState(null);
      const [loading, setLoading] = React.useState(true);
      const [error, setError] = React.useState(null);
      const [maxWinsLimit, setMaxWinsLimit] = React.useState(5);
      const [maxWinsInput, setMaxWinsInput] = React.useState("");
      const [maxWinsError, setMaxWinsError] = React.useState(null);
      const [gameMode, setGameMode] = React.useState("5x5");
      const [lastWinnerCourtA, setLastWinnerCourtA] = React.useState(null);
      const [swappingPlayer, setSwappingPlayer] = React.useState(null);
      const [swapError, setSwapError] = React.useState(null);
      const [pendingWinner, setPendingWinner] = React.useState(null);
      const [pendingStart, setPendingStart] = React.useState(null);
      const [pendingFirstStart, setPendingFirstStart] = React.useState(null);
      const saveLogCount = React.useRef(0);
      const MAX_SAVE_LOGS = 100; // Limit save logs to prevent console spam

      // Generate unique ID
      const generateId = () => `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;

      // Memoized getPlayerName
      const getPlayerName = React.useCallback((id) => {
        const player = players.find(p => p.id === id);
        if (!player) {
          console.warn(`getPlayerName: No player found for ID ${id}`);
          return "";
        }
        return player.name;
      }, [players]);

      // Debounce function for localStorage
      const debounce = (func, wait) => {
        let timeout;
        return (...args) => {
          clearTimeout(timeout);
          timeout = setTimeout(() => func(...args), wait);
        };
      };

      // getTeamSize before useEffect
      const getTeamSize = React.useCallback(() => {
        switch (gameMode) {
          case "5x5": return 5;
          case "4x4": return 4;
          case "3x3": return 3;
          default: return 5;
        }
      }, [gameMode]);

      // Load initial state
      React.useEffect(() => {
        try {
          const savedState = localStorage.getItem("bballManagerState");
          if (savedState) {
            const state = JSON.parse(savedState);
            setPlayers(state.players || []);
            setWaitlist(state.waitlist || []);
            setPausedList(state.pausedList || []);
            setNextTeam(state.nextTeam || []);
            setTeam1(state.team1 || []);
            setTeam2(state.team2 || []);
            setTeam3(state.team3 || []);
            setTeam4(state.team4 || []);
            setTeam1Wins(state.team1Wins || 0);
            setTeam3Wins(state.team3Wins || 0);
            setGameStartedA(state.gameStartedA || false);
            setGameStartedB(state.gameStartedB || false);
            setPostMaxOutA(state.postMaxOutA || false);
            setPostMaxOutB(state.postMaxOutB || false);
            setTeam1Label(state.team1Label || "Team 1");
            setTeam2Label(state.team2Label || "Team 2");
            setTeam3Label(state.team3Label || "Team 3");
            setTeam4Label(state.team4Label || "Team 4");
            setMaxWinsLimit(state.maxWinsLimit || 5);
            setGameMode(state.gameMode || "5x5");
            setLastWinnerCourtA(state.lastWinnerCourtA || null);
          }
          setLoading(false);
        } catch (err) {
          setError("Failed to load data. Please refresh.");
          setLoading(false);
        }
      }, []);

      // Save state to localStorage with debounce
      React.useEffect(() => {
        const saveState = debounce(() => {
          if (saveLogCount.current < MAX_SAVE_LOGS) {
            try {
              const state = { 
                players, 
                waitlist, 
                nextTeam, 
                team1, 
                team2, 
                team3, 
                team4, 
                team1Wins, 
                team3Wins, 
                gameStartedA, 
                gameStartedB, 
                postMaxOutA,
                postMaxOutB,
                team1Label, 
                team2Label, 
                team3Label, 
                team4Label, 
                maxWinsLimit, 
                gameMode, 
                lastWinnerCourtA 
              };
              localStorage.setItem("bballManagerState", JSON.stringify(state));
              console.log("Saved state to localStorage:", { nextTeam: nextTeam.map(getPlayerName), waitlist: waitlist.map(getPlayerName) });
              saveLogCount.current += 1;
              if (saveLogCount.current >= MAX_SAVE_LOGS) {
                console.log("Max save logs reached. Suppressing further save logs.");
              }
              if (window.performance && performance.memory) {
                console.log("Memory usage:", performance.memory.usedJSHeapSize / 1024 / 1024, "MB");
              }
            } catch (err) {
              setError("Failed to save data to localStorage. Check storage settings.");
              console.error(err);
            }
          }
        }, 500);

        saveState();
        return () => clearTimeout(saveState);
      }, [players, waitlist, nextTeam, team1, team2, team3, team4, team1Wins, team3Wins, gameStartedA, gameStartedB, postMaxOutA, postMaxOutB, maxWinsLimit, gameMode, getPlayerName]);

      // Simplified fillNextTeam
      const fillNextTeam = React.useCallback(() => {
        if (gameMode === "3x3") {
          console.log(`fillNextTeam: ${gameMode} mode not implemented yet.`);
          return;
        }
        const teamSize = getTeamSize();
        console.log("fillNextTeam: Starting - Waitlist:", waitlist.map(getPlayerName), 
                    "NextTeam:", nextTeam.map(getPlayerName), 
                    "TeamSize:", teamSize);
        let newNextTeam = [...nextTeam];
        let newWaitlist = [...waitlist];
        if (newNextTeam.length < teamSize && newWaitlist.length > 0) {
          while (newNextTeam.length < teamSize && newWaitlist.length > 0) {
            const playerId = newWaitlist[0];
            if (players.find(p => p.id === playerId) && !newNextTeam.includes(playerId)) {
              newNextTeam.push(playerId);
              newWaitlist.shift();
              console.log("fillNextTeam: Added player", getPlayerName(playerId), "to nextTeam");
            } else {
              console.warn("fillNextTeam: Skipping invalid or duplicate player ID:", playerId);
              newWaitlist.shift();
            }
          }
          setNextTeam(newNextTeam);
          setWaitlist(newWaitlist);
        } else {
          console.log("fillNextTeam: Skipped - NextTeam full or waitlist empty.");
        }
        console.log("fillNextTeam: Completed - Waitlist:", newWaitlist.map(getPlayerName), 
                    "NextTeam:", newNextTeam.map(getPlayerName));
      }, [players, waitlist, nextTeam, gameMode, getPlayerName, getTeamSize]);

      // fillNextTeam useEffect
      React.useEffect(() => {
        const teamSize = getTeamSize();
        if (nextTeam.length >= teamSize || waitlist.length === 0) {
          console.log("useEffect: Skipping fillNextTeam - NextTeam full or waitlist empty.", 
                      "NextTeam:", nextTeam.map(getPlayerName), 
                      "Waitlist:", waitlist.map(getPlayerName));
          return;
        }
        console.log("useEffect: Triggering fillNextTeam - Waitlist:", waitlist.map(getPlayerName), 
                    "NextTeam:", nextTeam.map(getPlayerName));
        fillNextTeam();
      }, [waitlist, nextTeam, gameMode, getPlayerName, fillNextTeam, getTeamSize]);

      // Debug UI rendering
      React.useEffect(() => {
        console.log("UI Rendering - Waitlist:", waitlist.map(getPlayerName), 
                    "NextTeam:", nextTeam.map(getPlayerName));
      }, [waitlist, nextTeam, getPlayerName]);

      const totalCount = players.length;

      React.useEffect(() => {
        if (totalCount < 16 && totalCount >= 10 && gameMode === "4x4") {
          setGameMode("5x5");
          setTeam3([]);
          setTeam4([]);
          setTeam3Wins(0);
          setGameStartedB(false);
          setPostMaxOutB(false);
          setTeam3Label("Team 3");
          setTeam4Label("Team 4");
          setLastWinnerCourtA(null);
          console.log("Auto-switched to 5x5 mode due to insufficient players (< 16).");
        }
      }, [totalCount, gameMode]);

      const addPlayer = React.useCallback(() => {
        console.log("addPlayer called with name:", playerName);
        const name = playerName.trim();
        if (!name) {
          setSignupError("Please enter a valid name.");
          console.log("addPlayer: Empty name entered.");
          return;
        }
        if (name.length > 15) {
          setSignupError("Player name must be 15 characters or less.");
          console.log("addPlayer: Name too long:", name);
          return;
        }
        const normalizedName = name.toLowerCase().trim();
        const isDuplicate = players.some(p => p.name.toLowerCase().trim() === normalizedName);
        console.log("addPlayer: Duplicate check for", name, "result:", isDuplicate);
        if (isDuplicate) {
          setSignupError("Player name already exists.");
          return;
        }
        const newPlayer = { id: generateId(), name, wins: 0, losses: 0, winStreak: 0 };
        setPlayers(prev => {
          const newPlayers = [...prev, newPlayer];
          console.log("addPlayer: Updated Players:", newPlayers.map(p => p.name));
          return newPlayers;
        });
        setWaitlist(prev => {
          const newWaitlist = [...prev, newPlayer.id];
          console.log("addPlayer: Updated Waitlist:", newWaitlist.map(getPlayerName));
          return newWaitlist;
        });
        setPlayerName("");
        setSignupError(null);
        console.log("addPlayer: Triggering fillNextTeam");
        fillNextTeam();
      }, [playerName, players, getPlayerName, fillNextTeam]);

      const pausePlayer = React.useCallback((id) => {
        console.log("pausePlayer called for player ID:", id, "Name:", getPlayerName(id));
        setWaitlist(prev => prev.filter(pid => pid !== id));
        setPausedList(prev => [...prev, id]);
      }, [getPlayerName]);

      const readyPlayer = React.useCallback((id) => {
        console.log("readyPlayer called for player ID:", id, "Name:", getPlayerName(id));
        setPausedList(prev => prev.filter(pid => pid !== id));
        setWaitlist(prev => [...prev, id]);
      }, [getPlayerName]);

      const removePlayer = React.useCallback((id) => {
        console.log("removePlayer called for player ID:", id, "Name:", getPlayerName(id));
        setPlayers(prev => prev.filter(p => p.id !== id));
        setWaitlist(prev => prev.filter(pid => pid !== id));
        setPausedList(prev => prev.filter(pid => pid !== id));
        setNextTeam(prev => prev.filter(pid => pid !== id));
        setTeam1(prev => prev.filter(pid => pid !== id));
        setTeam2(prev => prev.filter(pid => pid !== id));
        setTeam3(prev => prev.filter(pid => pid !== id));
        setTeam4(prev => prev.filter(pid => pid !== id));
        console.log("removePlayer: After removal - Waitlist:", waitlist.filter(pid => pid !== id).map(getPlayerName), 
                    "NextTeam:", nextTeam.filter(pid => pid !== id).map(getPlayerName));
      }, [waitlist, nextTeam, getPlayerName]);

      const startSwap = React.useCallback((id, sourceList) => {
        console.log("startSwap called for player ID:", id, "Name:", getPlayerName(id), 
                    "SourceList:", sourceList);
        if (waitlist.length === 0) {
          setSwapError("No players available on Waitlist to swap.");
          console.log("startSwap: Aborted - Waitlist empty.");
          return;
        }
        setSwappingPlayer({ id, sourceList });
        setSwapError(null);
      }, [waitlist, getPlayerName]);

      const completeSwap = React.useCallback((waitlistPlayerId) => {
        if (!swappingPlayer || !waitlist.includes(waitlistPlayerId)) {
          setSwapError("Invalid player selection for swap.");
          console.warn("completeSwap: Invalid player IDs - SwappingPlayer:", swappingPlayer, "Waitlist:", waitlist);
          setSwappingPlayer(null);
          return;
        }
        const { id: sourcePlayerId, sourceList } = swappingPlayer;
        console.log("completeSwap called. Swapping player ID:", sourcePlayerId, "Name:", getPlayerName(sourcePlayerId), 
                    "from", sourceList, 
                    "with Waitlist player ID:", waitlistPlayerId, "Name:", getPlayerName(waitlistPlayerId));

        let isValid = false;
        switch (sourceList) {
          case "waitlist": isValid = waitlist.includes(sourcePlayerId); break;
          case "pausedList": isValid = pausedList.includes(sourcePlayerId); break;
          case "nextTeam": isValid = nextTeam.includes(sourcePlayerId); break;
          case "team1": isValid = team1.includes(sourcePlayerId); break;
          case "team2": isValid = team2.includes(sourcePlayerId); break;
          case "team3": isValid = team3.includes(sourcePlayerId); break;
          case "team4": isValid = team4.includes(sourcePlayerId); break;
          default: console.warn("completeSwap: Invalid sourceList:", sourceList);
        }
        if (!isValid) {
          setSwapError("Source player not found in specified list.");
          console.warn("completeSwap: Source player ID", sourcePlayerId, "not in", sourceList);
          setSwappingPlayer(null);
          return;
        }

        switch (sourceList) {
          case "waitlist":
            setWaitlist(prev => prev.map(id => id === sourcePlayerId ? waitlistPlayerId : id === waitlistPlayerId ? sourcePlayerId : id));
            break;
          case "pausedList":
            setPausedList(prev => prev.filter(id => id !== sourcePlayerId).concat(waitlistPlayerId));
            setWaitlist(prev => prev.filter(id => id !== waitlistPlayerId).concat(sourcePlayerId));
            break;
          case "nextTeam":
            setNextTeam(prev => prev.filter(id => id !== sourcePlayerId).concat(waitlistPlayerId));
            setWaitlist(prev => prev.filter(id => id !== waitlistPlayerId).concat(sourcePlayerId));
            break;
          case "team1":
            setTeam1(prev => prev.filter(id => id !== sourcePlayerId).concat(waitlistPlayerId));
            setWaitlist(prev => prev.filter(id => id !== waitlistPlayerId).concat(sourcePlayerId));
            break;
          case "team2":
            setTeam2(prev => prev.filter(id => id !== sourcePlayerId).concat(waitlistPlayerId));
            setWaitlist(prev => prev.filter(id => id !== waitlistPlayerId).concat(sourcePlayerId));
            break;
          case "team3":
            setTeam3(prev => prev.filter(id => id !== sourcePlayerId).concat(waitlistPlayerId));
            setWaitlist(prev => prev.filter(id => id !== waitlistPlayerId).concat(sourcePlayerId));
            break;
          case "team4":
            setTeam4(prev => prev.filter(id => id !== sourcePlayerId).concat(waitlistPlayerId));
            setWaitlist(prev => prev.filter(id => id !== waitlistPlayerId).concat(sourcePlayerId));
            break;
        }
        setSwappingPlayer(null);
        setSwapError(null);
      }, [swappingPlayer, waitlist, pausedList, nextTeam, team1, team2, team3, team4, getPlayerName]);

      const cancelSwap = React.useCallback(() => {
        console.log("cancelSwap called. Clearing swappingPlayer:", swappingPlayer);
        setSwappingPlayer(null);
        setSwapError(null);
      }, [swappingPlayer]);

      const shuffleArray = (array) => {
        const shuffled = [...array];
        for (let i = shuffled.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [shuffled[i], shuffled[j]] = [shuffled[i], shuffled[j]];
        }
        return shuffled;
      };

      const startFirstGame = React.useCallback((court) => {
        if (gameMode === "3x3") {
          alert(`${gameMode} mode not implemented yet.`);
          return;
        }
        const teamSize = getTeamSize();
        const minPlayers = gameMode === "5x5" ? teamSize * 2 : teamSize * 2; // 10 for 5x5, 8 for 4x4
        const minPlayersBothCourts = gameMode === "4x4" ? teamSize * 4 : teamSize * 2; // 16 for 4x4, 10 for 5x5
        console.log(`startFirstGame ${court}: Checking conditions - `, {
          gameMode,
          totalCount,
          minPlayers,
          minPlayersBothCourts,
          nextTeamLength: nextTeam.length,
          waitlistLength: waitlist.length,
          teamSize,
          gameStartedA,
          gameStartedB,
          postMaxOutA,
          postMaxOutB,
          nextTeam: nextTeam.map(getPlayerName),
          waitlist: waitlist.map(getPlayerName)
        });

        if (totalCount < minPlayers) {
          alert(`Need at least ${minPlayers} players for ${gameMode} mode on ${court}.`);
          console.warn(`startFirstGame ${court}: Failed - Insufficient total players (${totalCount} < ${minPlayers}).`);
          return;
        }
        if (nextTeam.length < teamSize) {
          alert(`Need at least ${teamSize} players on Next Team for ${court}.`);
          console.warn(`startFirstGame ${court}: Failed - Insufficient Next Team players (${nextTeam.length} < ${teamSize}).`);
          return;
        }
        if (waitlist.length < teamSize) {
          alert(`Need at least ${teamSize} players on Waitlist for ${court}.`);
          console.warn(`startFirstGame ${court}: Failed - Insufficient Waitlist players (${waitlist.length} < ${teamSize}).`);
          return;
        }

        if (gameMode === "4x4" && court === "A" && (!gameStartedA || postMaxOutA)) {
          // Start game on Court A only
          console.log(`startFirstGame: Starting 4x4 on Court A with ${totalCount} players.`);
          setGameStartedA(true);
          setPostMaxOutA(false);
          const newTeam1 = nextTeam.slice(0, teamSize);
          const newTeam2 = waitlist.slice(0, teamSize);
          const newWaitlist = waitlist.slice(teamSize);
          setTeam1(newTeam1);
          setTeam2(newTeam2);
          setWaitlist(newWaitlist);
          setNextTeam([]);
          setTeam1Label("Team 1");
          setTeam2Label("Team 2");
          console.log(`startFirstGame: Assigned teams - Team1: ${newTeam1.map(getPlayerName)}, Team2: ${newTeam2.map(getPlayerName)}, Waitlist: ${newWaitlist.map(getPlayerName)}`);
          fillNextTeam();
        } else if (gameMode === "5x5" && court === "A" && (!gameStartedA || postMaxOutA)) {
          setGameStartedA(true);
          setPostMaxOutA(false);
          const newTeam1 = nextTeam.slice(0, teamSize);
          const newTeam2 = waitlist.slice(0, teamSize);
          const newWaitlist = waitlist.slice(teamSize);
          setTeam1(newTeam1);
          setTeam2(newTeam2);
          setWaitlist(newWaitlist);
          setNextTeam([]);
          setTeam1Label("Team 1");
          setTeam2Label("Team 2");
          console.log(`startFirstGame: Assigned teams - Team1: ${newTeam1.map(getPlayerName)}, Team2: ${newTeam2.map(getPlayerName)}, Waitlist: ${newWaitlist.map(getPlayerName)}`);
          fillNextTeam();
        } else if (gameMode === "4x4" && court === "B" && (!gameStartedB || postMaxOutB) && totalCount >= minPlayersBothCourts) {
          setGameStartedB(true);
          setPostMaxOutB(false);
          const newTeam3 = nextTeam.slice(0, teamSize);
          const newTeam4 = waitlist.slice(0, teamSize);
          const newWaitlist = waitlist.slice(teamSize);
          setTeam3(newTeam3);
          setTeam4(newTeam4);
          setWaitlist(newWaitlist);
          setNextTeam([]);
          setTeam3Label("Team 3");
          setTeam4Label("Team 4");
          console.log(`startFirstGame: Assigned teams - Team3: ${newTeam3.map(getPlayerName)}, Team4: ${newTeam4.map(getPlayerName)}, Waitlist: ${newWaitlist.map(getPlayerName)}`);
          fillNextTeam();
        } else {
          console.warn(`startFirstGame ${court}: Failed conditions - `, {
            gameMode,
            court,
            gameStartedA,
            gameStartedB,
            postMaxOutA,
            postMaxOutB
          });
          alert(`Cannot start game on ${court}. Check game mode and active games.`);
        }
      }, [gameMode, totalCount, nextTeam, waitlist, getTeamSize, getPlayerName, gameStartedA, gameStartedB, postMaxOutA, postMaxOutB]);

      const initiateFirstGame = React.useCallback((court) => {
        console.log(`initiateFirstGame called for Court: ${court}`);
        const teamSize = getTeamSize();
        const minPlayers = gameMode === "5x5" ? teamSize * 2 : teamSize * 2;
        const newTeam1 = nextTeam.slice(0, teamSize);
        const newTeam2 = waitlist.slice(0, teamSize);
        const message = `Start fresh game on Court ${court}?<br/>Team 1 (${newTeam1.map(getPlayerName).join(", ")})<br/>vs<br/>Team 2 (${newTeam2.map(getPlayerName).join(", ")})`;
        setPendingFirstStart({ court, message });
      }, [gameMode, nextTeam, waitlist, getTeamSize, getPlayerName]);

      const confirmFirstGame = React.useCallback(() => {
        if (!pendingFirstStart) {
          console.warn("confirmFirstGame: No pending first start to confirm.");
          return;
        }
        console.log(`confirmFirstGame: Confirmed start for Court: ${pendingFirstStart.court}`);
        startFirstGame(pendingFirstStart.court);
        setPendingFirstStart(null);
      }, [pendingFirstStart, startFirstGame]);

      const cancelFirstGame = React.useCallback(() => {
        console.log("cancelFirstGame called. Clearing pendingFirstStart:", pendingFirstStart);
        setPendingFirstStart(null);
      }, [pendingFirstStart]);

      const startNextGame = React.useCallback((court) => {
        if (gameMode === "3x3") {
          alert(`${gameMode} mode not implemented yet.`);
          return;
        }
        const teamSize = getTeamSize();
        const minPlayers = gameMode === "5x5" ? teamSize * 2 : teamSize * 4;
        if (totalCount < minPlayers) {
          alert(`Need at least ${minPlayers} players for ${gameMode} mode.`);
          return;
        }
        if (nextTeam.length < teamSize) {
          alert(`Not enough players in Next Team (need ${teamSize}) for ${court}.`);
          return;
        }
        if (court === "A") {
          setTeam2(nextTeam.slice(0, teamSize));
          setNextTeam([]);
          setTeam2Label("Team 2 (Challengers)");
          setTeam1Label("Team 1 (Winners)");
          console.log(`startNextGame: Court A - Team2: ${nextTeam.slice(0, teamSize).map(getPlayerName)}, NextTeam cleared`);
          fillNextTeam();
        } else if (court === "B") {
          setTeam4(nextTeam.slice(0, teamSize));
          setNextTeam([]);
          setTeam4Label("Team 4 (Challengers)");
          setTeam3Label("Team 3 (Winners)");
          console.log(`startNextGame: Court B - Team4: ${nextTeam.slice(0, teamSize).map(getPlayerName)}, NextTeam cleared`);
          fillNextTeam();
        }
      }, [gameMode, totalCount, nextTeam, getTeamSize, getPlayerName]);

      const initiateStartNextGame = React.useCallback((court) => {
        console.log(`initiateStartNextGame called for Court: ${court}`);
        const teamSize = getTeamSize();
        const newTeam = nextTeam.slice(0, teamSize);
        let message = `Start next game on Court ${court}?<br/>Challengers:<br/>Next Team (${newTeam.map(getPlayerName).join(", ")})`;
        if (court === "A" && team1Wins === maxWinsLimit - 1) {
          message += `<br/><span class="text-red-500"><strong><u>Note</u></strong>: ${team1Label} is one win away from max wins (${maxWinsLimit}).</span>`;
        } else if (court === "B" && team3Wins === maxWinsLimit - 1) {
          message += `<br/><span class="text-red-500"><strong><u>Note</u></strong>: ${team3Label} is one win away from max wins (${maxWinsLimit}).</span>`;
        }
        setPendingStart({ court, message });
      }, [nextTeam, getTeamSize, getPlayerName, team1Wins, team3Wins, maxWinsLimit, team1Label, team3Label]);

      const confirmStartNextGame = React.useCallback(() => {
        if (!pendingStart) {
          console.warn("confirmStartNextGame: No pending start to confirm.");
          return;
        }
        console.log(`confirmStartNextGame: Confirmed start for Court: ${pendingStart.court}`);
        startNextGame(pendingStart.court);
        setPendingStart(null);
      }, [pendingStart, startNextGame]);

      const cancelStartNextGame = React.useCallback(() => {
        console.log("cancelStartNextGame called. Clearing pendingStart:", pendingStart);
        setPendingStart(null);
      }, [pendingStart]);

      const initiateWinnerConfirmation = React.useCallback((court, winner) => {
        console.log(`initiateWinnerConfirmation called for Court: ${court}, Winner: ${winner}`);
        let message = "";
        let winningTeam = [];
        if (court === "A") {
          winningTeam = winner === "Team 1" ? team1 : team2;
        } else if (court === "B") {
          winningTeam = winner === "Team 3" ? team3 : team4;
        }
        message = `Confirm winner on Court ${court}?<br/>${winner} (${winningTeam.map(getPlayerName).join(", ")})`;
        setPendingWinner({ court, winner, message });
      }, [team1, team2, team3, team4, getPlayerName]);

      const confirmWinner = React.useCallback(() => {
        if (!pendingWinner) {
          console.warn("confirmWinner: No pending winner to confirm.");
          return;
        }
        const { court, winner } = pendingWinner;
        console.log(`confirmWinner: Confirmed winner for Court: ${court}, Winner: ${winner}`);
        declareWinner(court, winner);
        setPendingWinner(null);
      }, [pendingWinner]);

      const cancelWinnerConfirmation = React.useCallback(() => {
        console.log("cancelWinnerConfirmation called. Clearing pendingWinner:", pendingWinner);
        setPendingWinner(null);
      }, [pendingWinner]);

      const declareWinner = React.useCallback((court, winner) => {
        if (gameMode === "3x3") {
          alert(`${gameMode} mode not implemented yet.`);
          return;
        }
        const teamSize = getTeamSize();
        let winners, losers, newTeam1, newTeam3, newTeam1Wins, newTeam3Wins, newTeam1Label, newTeam2Label, newTeam3Label, newTeam4Label;

        if (court === "A") {
          if (winner === "Team 1") {
            winners = team1;
            losers = team2;
            newTeam1 = team1;
            newTeam1Wins = team1Wins + 1;
            newTeam1Label = "Team 1 (Winners)";
            newTeam2Label = "Team 2";
          } else {
            winners = team2;
            losers = team1;
            newTeam1 = team2;
            newTeam1Wins = 1;
            newTeam1Label = "Team 1 (Winners)";
            newTeam2Label = "Team 2";
          }
          setLastWinnerCourtA(winners);
        } else if (court === "B") {
          if (winner === "Team 3") {
            winners = team3;
            losers = team4;
            newTeam3 = team3;
            newTeam3Wins = team3Wins + 1;
            newTeam3Label = "Team 3 (Winners)";
            newTeam4Label = "Team 4";
          } else {
            winners = team4;
            losers = team3;
            newTeam3 = team4;
            newTeam3Wins = 1;
            newTeam3Label = "Team 3 (Winners)";
            newTeam4Label = "Team 4";
          }
        }

        setPlayers(prev => prev.map(p => {
          if (winners.includes(p.id)) {
            return { ...p, wins: p.wins + 1, winStreak: p.winStreak + 1 };
          }
          if (losers.includes(p.id)) {
            return { ...p, losses: p.losses + 1, winStreak: 0 };
          }
          return p;
        }));

        let newWaitlist = [...waitlist];

        if ((court === "A" && newTeam1Wins >= maxWinsLimit) || (court === "B" && newTeam3Wins >= maxWinsLimit)) {
          if (court === "A") {
            newWaitlist = [...newWaitlist, ...newTeam1, ...losers];
            setTeam1([]);
            setTeam2([]);
            newWaitlist = shuffleArray(newWaitlist);
            setWaitlist(newWaitlist);
            setTeam1Wins(0);
            setTeam1Label("Team 1");
            setTeam2Label("Team 2");
            setGameStartedA(false);
            setPostMaxOutA(true);
            setLastWinnerCourtA(null);
            console.log(`declareWinner: Court A maxed out - Waitlist: ${newWaitlist.map(getPlayerName)}`);
            fillNextTeam();
          } else if (court === "B") {
            newWaitlist = [...newWaitlist, ...newTeam3, ...losers];
            setTeam3([]);
            setTeam4([]);
            newWaitlist = shuffleArray(newWaitlist);
            setWaitlist(newWaitlist);
            setTeam3Wins(0);
            setTeam3Label("Team 3");
            setTeam4Label("Team 4");
            setGameStartedB(false);
            setPostMaxOutB(true);
            console.log(`declareWinner: Court B maxed out - Waitlist: ${newWaitlist.map(getPlayerName)}`);
            fillNextTeam();
          }
        } else {
          if (court === "A") {
            setTeam1(newTeam1);
            setTeam2([]);
            setWaitlist([...newWaitlist, ...losers]);
            setTeam1Wins(newTeam1Wins);
            setTeam1Label(newTeam1Label);
            setTeam2Label(newTeam2Label);
            setPostMaxOutA(false);
            console.log(`declareWinner: Court A - Team1: ${newTeam1.map(getPlayerName)}, Waitlist: ${[...newWaitlist, ...losers].map(getPlayerName)}`);
            fillNextTeam();
          } else if (court === "B") {
            setTeam3(newTeam3);
            setTeam4([]);
            setWaitlist([...newWaitlist, ...losers]);
            setTeam3Wins(newTeam3Wins);
            setTeam3Label(newTeam3Label);
            setTeam4Label(newTeam4Label);
            setPostMaxOutB(false);
            console.log(`declareWinner: Court B - Team3: ${newTeam3.map(getPlayerName)}, Waitlist: ${[...newWaitlist, ...losers].map(getPlayerName)}`);
            fillNextTeam();
          }
        }
      }, [gameMode, maxWinsLimit, team1, team2, team3, team4, team1Wins, team3Wins, waitlist, players, getTeamSize, getPlayerName]);

      const setMaxWins = React.useCallback(() => {
        const value = parseInt(maxWinsInput, 10);
        if (isNaN(value) || value <= 0) {
          setMaxWinsError("Please enter a positive number.");
          return;
        }
        setMaxWinsLimit(value);
        setMaxWinsInput("");
        setMaxWinsError(null);
      }, [maxWinsInput]);

      const handleGameModeChange = React.useCallback((e) => {
        const newMode = e.target.value;
        const teamSize = newMode === "5x5" ? 5 : 4;
        const minPlayers = newMode === "5x5" ? 10 : 8;
        const minPlayersBothCourts = newMode === "4x4" ? 16 : 10;

        if (newMode === "3x3") {
          alert("3x3 mode not implemented yet.");
          return;
        }

        if (totalCount < minPlayers) {
          alert(`Need at least ${minPlayers} players for ${newMode} mode.`);
          return;
        }

        if (newMode === "4x4" && gameMode === "5x5" && gameStartedA && lastWinnerCourtA && totalCount >= minPlayersBothCourts) {
          const winners = shuffleArray([...lastWinnerCourtA]);
          const team1Winners = winners.slice(0, 3);
          const team3Winners = winners.slice(3, 5);
          let remainingNextTeam = [...nextTeam];
          let newWaitlist = [...waitlist];

          let newTeam1 = [...team1Winners];
          if (remainingNextTeam.length >= 1) {
            newTeam1.push(remainingNextTeam.shift());
          } else if (newWaitlist.length >= 1) {
            newTeam1.push(newWaitlist.shift());
          } else {
            alert("Not enough players to form Team 1 in 4x4-Split.");
            return;
          }

          let newTeam3 = [...team3Winners];
          if (remainingNextTeam.length >= 2) {
            newTeam3.push(...remainingNextTeam.splice(0, 2));
          } else if (remainingNextTeam.length === 1 && newWaitlist.length >= 1) {
            newTeam3.push(remainingNextTeam.shift(), newWaitlist.shift());
          } else if (newWaitlist.length >= 2) {
            newTeam3.push(...newWaitlist.splice(0, 2));
          } else {
            alert("Not enough players to form Team 3 in 4x4-Split.");
            return;
          }

          let newTeam2 = [];
          const team2Slots = 4;
          if (remainingNextTeam.length >= team2Slots) {
            newTeam2 = remainingNextTeam.splice(0, team2Slots);
          } else {
            newTeam2 = [...remainingNextTeam, ...newWaitlist.splice(0, team2Slots - remainingNextTeam.length)];
            remainingNextTeam = [];
          }

          let newTeam4 = [];
          if (newWaitlist.length >= 4) {
            newTeam4 = newWaitlist.splice(0, 4);
          } else {
            alert("Not enough players to form Team 4 in 4x4-Split.");
            return;
          }

          setGameMode(newMode);
          setGameStartedA(true);
          setGameStartedB(true);
          setPostMaxOutA(false);
          setPostMaxOutB(false);
          setTeam1(newTeam1);
          setTeam2(newTeam2);
          setTeam3(newTeam3);
          setTeam4(newTeam4);
          setWaitlist(newWaitlist);
          setNextTeam([]);
          setTeam1Wins(0);
          setTeam3Wins(0);
          setTeam1Label("Team 1");
          setTeam2Label("Team 2");
          setTeam3Label("Team 3");
          setTeam4Label("Team 4");
          setLastWinnerCourtA(null);
          console.log(`handleGameModeChange: Switched to 4x4 - Teams assigned, Waitlist: ${newWaitlist.map(getPlayerName)}`);
          fillNextTeam();
        } else if (newMode === "4x4" && (!gameStartedA && !gameStartedB && totalCount >= minPlayers)) {
          setGameMode(newMode);
          setPostMaxOutA(false);
          setPostMaxOutB(false);
          console.log(`handleGameModeChange: Switched to 4x4 - Ready to start games`);
        } else if (newMode === "5x5") {
          setGameMode(newMode);
          setTeam3([]);
          setTeam4([]);
          setTeam3Wins(0);
          setGameStartedB(false);
          setPostMaxOutB(false);
          setTeam3Label("Team 3");
          setTeam4Label("Team 4");
          setLastWinnerCourtA(null);
          console.log(`handleGameModeChange: Switched to 5x5 - Cleared Court B`);
        } else {
          alert(`Cannot switch to ${newMode} mode. Ensure sufficient players or no conflicting games.`);
        }
      }, [gameMode, totalCount, gameStartedA, gameStartedB, lastWinnerCourtA, nextTeam, waitlist]);

      const clearAll = React.useCallback(() => {
        setPlayers([]);
        setWaitlist([]);
        setPausedList([]);
        setNextTeam([]);
        setTeam1([]);
        setTeam2([]);
        setTeam3([]);
        setTeam4([]);
        setTeam1Wins(0);
        setTeam3Wins(0);
        setGameStartedA(false);
        setGameStartedB(false);
        setPostMaxOutA(false);
        setPostMaxOutB(false);
        setError(null);
        setSignupError(null);
        setMaxWinsLimit(5);
        setMaxWinsInput("");
        setMaxWinsError(null);
        setGameMode("5x5");
        setLastWinnerCourtA(null);
        setSwappingPlayer(null);
        setSwapError(null);
        setPendingWinner(null);
        setPendingStart(null);
        setPendingFirstStart(null);
        saveLogCount.current = 0;
        console.log("clearAll: Reset all state");
      }, []);

      const clearScores = React.useCallback(() => {
        setPlayers(prev => prev.map(p => ({ ...p, wins: 0, losses: 0, winStreak: 0 })));
        console.log("clearScores: Reset all player scores");
      }, []);

      const maxWins = Math.max(...players.map(p => p.wins), 0);
      const waitlistCount = new Set([...waitlist]).size;
      const pausedCount = pausedList.length;

      if (loading) {
        return React.createElement("div", { className: "text-center text-xl" }, "Loading...");
      }

      if (error) {
        return React.createElement("div", { className: "text-center text-red-500" },
          React.createElement("p", null, error),
          React.createElement("button", {
            onClick: () => window.location.reload(),
            className: "mt-2 bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700"
          }, "Try Again")
        );
      }

      return React.createElement("div", { className: "space-y-6" },
        React.createElement("h1", { className: "text-3xl font-bold text-center" }, "RFCN BBALL Game Manager"),
        React.createElement("div", { className: "flex justify-around bg-white p-4 rounded shadow" },
          React.createElement("p", { className: "font-semibold" }, `Total #: ${totalCount}`),
          React.createElement("p", { className: "font-semibold" }, `Waitlist #: ${waitlistCount}`),
          React.createElement("p", { className: "font-semibold" }, `Paused #: ${pausedCount}`)
        ),
        React.createElement("div", { className: "bg-white p-4 rounded shadow" },
          React.createElement("h2", { className: "text-xl font-semibold mb-2" }, "Player Signup"),
          React.createElement("div", { className: "flex flex-col space-y-2" },
            React.createElement("div", { className: "flex space-x-2" },
              React.createElement("input", {
                type: "text",
                value: playerName,
                onChange: (e) => { setPlayerName(e.target.value); setSignupError(null); },
                placeholder: "Enter player name (max 15 chars)",
                maxLength: 15,
                className: "flex-1 p-2 border rounded-lg"
              }),
              React.createElement("button", {
                onClick: addPlayer,
                className: "bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700"
              }, "Sign Up")
            ),
            signupError && React.createElement("p", { className: "text-red-500 text-sm" }, signupError)
          )
        ),
        React.createElement("div", { className: "grid grid-cols-1 md:grid-cols-3 gap-4" },
          React.createElement("div", { className: "bg-white p-4 rounded shadow" },
            React.createElement("h2", { className: "text-xl font-semibold mb-2" }, "Waitlist"),
            React.createElement("ul", { className: "space-y-2" },
              waitlist.map(id => React.createElement("li", { key: id, className: "flex justify-between items-center" },
                React.createElement("p", null, getPlayerName(id)),
                React.createElement("div", { className: "space-x-2" },
                  React.createElement("button", { 
                    onClick: () => startSwap(id, "waitlist"), 
                    disabled: waitlist.length <= 1,
                    className: "bg-purple-600 text-white px-2 py-1 rounded-lg hover:bg-purple-700 disabled:bg-gray-400"
                  }, "Swap"),
                  React.createElement("button", { 
                    onClick: () => pausePlayer(id), 
                    className: "bg-yellow-500 text-white px-2 py-1 rounded-lg hover:bg-yellow-600" 
                  }, "Pause"),
                  React.createElement("button", { 
                    onClick: () => removePlayer(id), 
                    className: "bg-red-600 text-white px-2 py-1 rounded-lg hover:bg-red-700" 
                  }, "Remove")
                )
              ))
            )
          ),
          React.createElement("div", { className: "bg-white p-4 rounded shadow" },
            React.createElement("h2", { className: "text-xl font-semibold mb-2" }, "Paused List"),
            React.createElement("ul", { className: "space-y-2" },
              pausedList.map(id => React.createElement("li", { key: id, className: "flex justify-between items-center" },
                React.createElement("p", null, getPlayerName(id)),
                React.createElement("div", { className: "space-x-2" },
                  React.createElement("button", { 
                    onClick: () => startSwap(id, "pausedList"), 
                    disabled: waitlist.length === 0,
                    className: "bg-purple-600 text-white px-2 py-1 rounded-lg hover:bg-purple-700 disabled:bg-gray-400"
                  }, "Swap"),
                  React.createElement("button", { 
                    onClick: () => readyPlayer(id), 
                    className: "bg-green-600 text-white px-2 py-1 rounded-lg hover:bg-green-700" 
                  }, "Ready")
                )
              ))
            )
          ),
          React.createElement("div", { className: "bg-white p-4 rounded shadow" },
            React.createElement("h2", { className: "text-xl font-semibold mb-2" }, "Next Team"),
            React.createElement("ul", { className: "space-y-2" },
              nextTeam.map(id => React.createElement("li", { key: id, className: "flex justify-between items-center" },
                React.createElement("p", null, getPlayerName(id)),
                React.createElement("button", { 
                  onClick: () => startSwap(id, "nextTeam"), 
                  disabled: waitlist.length === 0,
                  className: "bg-purple-600 text-white px-2 py-1 rounded-lg hover:bg-purple-700 disabled:bg-gray-400"
                }, "Swap")
              ))
            )
          ),
          swappingPlayer && React.createElement("div", { className: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center" },
            React.createElement("div", { className: "bg-white p-6 rounded-lg shadow-lg max-w-md w-full" },
              React.createElement("h3", { className: "text-lg font-semibold mb-4" }, 
                `Select Waitlist Player to Swap with ${getPlayerName(swappingPlayer.id)}`),
              React.createElement("ul", { className: "space-y-2 mb-4" },
                waitlist.filter(id => id !== swappingPlayer.id).map(id => 
                  React.createElement("li", { key: id, className: "flex justify-between items-center" },
                    React.createElement("p", null, getPlayerName(id)),
                    React.createElement("button", {
                      onClick: () => completeSwap(id),
                      className: "bg-blue-600 text-white px-2 py-1 rounded-lg hover:bg-blue-700"
                    }, "Select")
                  )
                )
              ),
              swapError && React.createElement("p", { className: "text-red-500 text-sm mb-4" }, swapError),
              React.createElement("button", {
                onClick: cancelSwap,
                className: "bg-gray-500 text-white px-4 py-2 rounded-lg hover:bg-gray-600"
              }, "Cancel")
            )
          ),
          pendingWinner && React.createElement("div", { className: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center" },
            React.createElement("div", { className: "bg-white p-6 rounded-lg shadow-lg max-w-md w-full" },
              React.createElement("h3", { className: "text-lg font-semibold mb-4", dangerouslySetInnerHTML: { __html: pendingWinner.message } }),
              React.createElement("div", { className: "flex justify-end space-x-4" },
                React.createElement("button", {
                  onClick: confirmWinner,
                  className: "bg-green-600 text-white px-4 py-2 rounded-lg hover:bg-green-700"
                }, "Confirm"),
                React.createElement("button", {
                  onClick: cancelWinnerConfirmation,
                  className: "bg-gray-500 text-white px-4 py-2 rounded-lg hover:bg-gray-600"
                }, "Cancel")
              )
            )
          ),
          pendingStart && React.createElement("div", { className: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center" },
            React.createElement("div", { className: "bg-white p-6 rounded-lg shadow-lg max-w-md w-full" },
              React.createElement("h3", { className: "text-lg font-semibold mb-4", dangerouslySetInnerHTML: { __html: pendingStart.message } }),
              React.createElement("div", { className: "flex justify-end space-x-4" },
                React.createElement("button", {
                  onClick: confirmStartNextGame,
                  className: "bg-green-600 text-white px-4 py-2 rounded-lg hover:bg-green-700"
                }, "Confirm"),
                React.createElement("button", {
                  onClick: cancelStartNextGame,
                  className: "bg-gray-500 text-white px-4 py-2 rounded-lg hover:bg-gray-600"
                }, "Cancel")
              )
            )
          ),
          pendingFirstStart && React.createElement("div", { className: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center" },
            React.createElement("div", { className: "bg-white p-6 rounded-lg shadow-lg max-w-md w-full" },
              React.createElement("h3", { className: "text-lg font-semibold mb-4", dangerouslySetInnerHTML: { __html: pendingFirstStart.message } }),
              React.createElement("div", { className: "flex justify-end space-x-4" },
                React.createElement("button", {
                  onClick: confirmFirstGame,
                  className: "bg-green-600 text-white px-4 py-2 rounded-lg hover:bg-green-700"
                }, "Confirm"),
                React.createElement("button", {
                  onClick: cancelFirstGame,
                  className: "bg-gray-500 text-white px-4 py-2 rounded-lg hover:bg-gray-600"
                }, "Cancel")
              )
            )
          )
        ),
        React.createElement("div", { className: "bg-white p-4 rounded shadow" },
          React.createElement("h2", { className: "text-xl font-semibold mb-2" }, "How We Play Around Here"),
          React.createElement("ul", { className: "list-disc list-inside space-y-2" },
            React.createElement("li", null, "Love God, Love Others, Be Grateful!"),
            React.createElement("li", null, "Respect Each Other; Respect the Call."),
            React.createElement("li", null, "Minimum Age: 16")
          )
        ),
        React.createElement("div", { className: "grid grid-cols-1 md:grid-cols-2 gap-4" },
          React.createElement("div", { className: "space-y-6" },
            React.createElement("div", { className: "bg-white p-4 rounded shadow" },
              React.createElement("h2", { className: "text-xl font-semibold mb-2" }, "Court A"),
              React.createElement("div", { className: "grid grid-cols-1 md:grid-cols-2 gap-4" },
                React.createElement("div", null,
                  React.createElement("h3", { className: "text-lg font-semibold mb-2" }, team1Label),
                  React.createElement("ul", { className: "space-y-2" },
                    team1.map(id => React.createElement("li", { key: id, className: "flex justify-between items-center" },
                      React.createElement("p", null, getPlayerName(id)),
                      React.createElement("button", { 
                        onClick: () => startSwap(id, "team1"), 
                        disabled: waitlist.length === 0,
                        className: "bg-purple-600 text-white px-2 py-1 rounded-lg hover:bg-purple-700 disabled:bg-gray-400"
                      }, "Swap")
                    ))
                  ),
                  gameStartedA && team2.length > 0 && React.createElement("button", {
                    onClick: () => initiateWinnerConfirmation("A", "Team 1"),
                    className: "mt-2 w-full bg-green-600 text-white px-4 py-2 rounded-lg hover:bg-green-700"
                  }, `${team1Label} Wins`)
                ),
                React.createElement("div", null,
                  React.createElement("h3", { className: "text-lg font-semibold mb-2" }, team2Label),
                  React.createElement("ul", { className: "space-y-2" },
                    team2.map(id => React.createElement("li", { key: id, className: "flex justify-between items-center" },
                      React.createElement("p", null, getPlayerName(id)),
                      React.createElement("button", { 
                        onClick: () => startSwap(id, "team2"), 
                        disabled: waitlist.length === 0,
                        className: "bg-purple-600 text-white px-2 py-1 rounded-lg hover:bg-purple-700 disabled:bg-gray-400"
                      }, "Swap")
                    ))
                  ),
                  gameStartedA && team2.length > 0 && React.createElement("button", {
                    onClick: () => initiateWinnerConfirmation("A", "Team 2"),
                    className: "mt-2 w-full bg-green-600 text-white px-4 py-2 rounded-lg hover:bg-green-700"
                  }, `${team2Label} Wins`)
                )
              ),
              React.createElement("div", { className: "flex justify-center space-x-4 mt-4" },
                React.createElement("button", {
                  onClick: () => initiateFirstGame("A"),
                  disabled: gameStartedA && !postMaxOutA || totalCount < (gameMode === "5x5" ? 10 : 8),
                  className: "bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 disabled:bg-gray-400"
                }, postMaxOutA ? "Start Fresh Game" : "Start First Game: Court A"),
                React.createElement("button", {
                  onClick: () => initiateStartNextGame("A"),
                  disabled: totalCount < (gameMode === "5x5" ? 10 : 8) || team2.length > 0 || postMaxOutA,
                  className: "bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 disabled:bg-gray-400"
                }, "Start Next Game: Court A")
              )
            ),
            gameMode === "4x4" && React.createElement("div", { className: "bg-white p-4 rounded shadow" },
              React.createElement("h2", { className: "text-xl font-semibold mb-2" }, "Court B"),
              React.createElement("div", { className: "grid grid-cols-1 md:grid-cols-2 gap-4" },
                React.createElement("div", null,
                  React.createElement("h3", { className: "text-lg font-semibold mb-2" }, team3Label),
                  React.createElement("ul", { className: "space-y-2" },
                    team3.map(id => React.createElement("li", { key: id, className: "flex justify-between items-center" },
                      React.createElement("p", null, getPlayerName(id)),
                      React.createElement("button", { 
                        onClick: () => startSwap(id, "team3"), 
                        disabled: waitlist.length === 0,
                        className: "bg-purple-600 text-white px-2 py-1 rounded-lg hover:bg-purple-700 disabled:bg-gray-400"
                      }, "Swap")
                    ))
                  ),
                  gameStartedB && team4.length > 0 && React.createElement("button", {
                    onClick: () => initiateWinnerConfirmation("B", "Team 3"),
                    className: "mt-2 w-full bg-green-600 text-white px-4 py-2 rounded-lg hover:bg-green-700"
                  }, `${team3Label} Wins`)
                ),
                React.createElement("div", null,
                  React.createElement("h3", { className: "text-lg font-semibold mb-2" }, team4Label),
                  React.createElement("ul", { className: "space-y-2" },
                    team4.map(id => React.createElement("li", { key: id, className: "flex justify-between items-center" },
                      React.createElement("p", null, getPlayerName(id)),
                      React.createElement("button", { 
                        onClick: () => startSwap(id, "team4"), 
                        disabled: waitlist.length === 0,
                        className: "bg-purple-600 text-white px-2 py-1 rounded-lg hover:bg-purple-700 disabled:bg-gray-400"
                      }, "Swap")
                    ))
                  ),
                  gameStartedB && team4.length > 0 && React.createElement("button", {
                    onClick: () => initiateWinnerConfirmation("B", "Team 4"),
                    className: "mt-2 w-full bg-green-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700"
                  }, `${team4Label} Wins`)
                )
              ),
              React.createElement("div", { className: "flex justify-center space-x-4 mt-4" },
                React.createElement("button", {
                  onClick: () => initiateFirstGame("B"),
                  disabled: gameStartedB && !postMaxOutB || totalCount < 16,
                  className: "bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 disabled:bg-gray-400"
                }, postMaxOutB ? "Start Fresh Game" : "Start First Game: Court B"),
                React.createElement("button", {
                  onClick: () => initiateStartNextGame("B"),
                  disabled: totalCount < 16 || team4.length > 0 || postMaxOutB,
                  className: "bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 disabled:bg-gray-400"
                }, "Start Next Game: Court B")
              )
            )
          ),
          React.createElement("div", { className: "space-y-6" },
            React.createElement("div", { className: "flex flex-col items-center space-y-4" },
              React.createElement("div", { className: "flex justify-center space-x-4" },
                React.createElement("button", { 
                  onClick: clearAll, 
                  className: "bg-red-700 text-white px-4 py-2 rounded-lg hover:bg-red-800" 
                }, "Clear All"),
                React.createElement("button", { 
                  onClick: clearScores, 
                  className: "bg-orange-600 text-white px-4 py-2 rounded-lg hover:bg-orange-700" 
                }, "Clear Scores")
              ),
              React.createElement("div", { className: "bg-white p-4 rounded shadow w-full max-w-md" },
                React.createElement("h3", { className: "text-lg font-semibold mb-2" }, `Game Mode: ${gameMode}`),
                React.createElement("div", { className: "flex space-x-2" },
                  React.createElement("select", {
                    value: gameMode,
                    onChange: handleGameModeChange,
                    className: "flex-1 p-2 border rounded-lg"
                  },
                    React.createElement("option", { value: "5x5" }, "5x5"),
                    React.createElement("option", { value: "4x4" }, "4x4"),
                    React.createElement("option", { value: "3x3" }, "3x3")
                  )
                )
              ),
              React.createElement("div", { className: "bg-white p-4 rounded shadow w-full max-w-md" },
                React.createElement("h3", { className: "text-lg font-semibold mb-2" }, `Max Wins: ${maxWinsLimit}`),
                React.createElement("div", { className: "flex space-x-2" },
                  React.createElement("input", {
                    type: "number",
                    value: maxWinsInput,
                    onChange: (e) => { setMaxWinsInput(e.target.value); setMaxWinsError(null); },
                    placeholder: "Set max wins",
                    className: "flex-1 p-2 border rounded-lg"
                  }),
                  React.createElement("button", {
                    onClick: setMaxWins,
                    className: "bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700"
                  }, "Set")
                ),
                maxWinsError && React.createElement("p", { className: "text-red-500 text-sm mt-2" }, maxWinsError)
              ),
              React.createElement("div", { className: "bg-white p-4 rounded shadow w-full max-w-md" },
                React.createElement("h3", { className: "text-lg font-semibold mb-2" }, "Player Stats"),
                maxWins > 0 && React.createElement("p", { className: "mb-2" }, 
                  `Leader Board Wins: ${maxWins} by `,
                  players
                    .filter(p => p.wins === maxWins)
                    .map(p => p.name)
                    .join(", ")
                ),
                React.createElement("ul", { className: "space-y-2" },
                  players.map(p => React.createElement("li", { key: p.id, className: "flex justify-between" },
                    React.createElement("p", null, `${p.name}: ${p.wins}W-${p.losses}L (Streak: ${p.winStreak})`)
                  ))
                )
              )
            )
          )
        )
      );
    });

    ReactDOM.render(React.createElement(App), document.getElementById("root"));
  </script>
</body>
</html>
