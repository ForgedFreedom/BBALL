<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>RFCN BBALL Game Manager - Web</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
</head>
<body class="bg-gray-100">
  <div id="root" className="container mx-auto p-4">App failed to load. Check console for errors.</div>
  <script type="text/javascript">
    // Version: 1.0.7 - 2025-06-28 - Added "How We Play Around Here" section with initial game rules
    // Version: 1.0.6 - 2025-06-28 - Added 15-character limit for player names in signup
    // Version: 1.0.5 - 2025-06-28 - Fixed runtime error 'Cannot access startNextGame before initialization' by reordering function declarations
    // Version: 1.0.4 - 2025-06-28 - Added confirmation modal for Start Next Game with Next Team players, winning team, and max wins note
    // Version: 1.0.3 - 2025-06-28 - Added team players to winner confirmation modal message
    // Version: 1.0.2 - 2025-06-28 - Fixed syntax error causing 'Unexpected end of input'
    // Version: 1.0.1 - 2025-06-28 - Added confirmation modal for winner selection
    // Version: 1.0.0 - 2025-06-27 - Initial version with button50 fixed to button in Court B section
    const App = React.memo(() => {
      const [players, setPlayers] = React.useState([]);
      const [waitlist, setWaitlist] = React.useState([]);
      const [pausedList, setPausedList] = React.useState([]);
      const [nextTeam, setNextTeam] = React.useState([]);
      const [team1, setTeam1] = React.useState([]);
      const [team2, setTeam2] = React.useState([]);
      const [team3, setTeam3] = React.useState([]);
      const [team4, setTeam4] = React.useState([]);
      const [team1Wins, setTeam1Wins] = React.useState(0);
      const [team3Wins, setTeam3Wins] = React.useState(0);
      const [gameStartedA, setGameStartedA] = React.useState(false);
      const [gameStartedB, setGameStartedB] = React.useState(false);
      const [team1Label, setTeam1Label] = React.useState("Team 1");
      const [team2Label, setTeam2Label] = React.useState("Team 2");
      const [team3Label, setTeam3Label] = React.useState("Team 3");
      const [team4Label, setTeam4Label] = React.useState("Team 4");
      const [playerName, setPlayerName] = React.useState("");
      const [signupError, setSignupError] = React.useState(null);
      const [loading, setLoading] = React.useState(true);
      const [error, setError] = React.useState(null);
      const [maxWinsLimit, setMaxWinsLimit] = React.useState(5);
      const [maxWinsInput, setMaxWinsInput] = React.useState("");
      const [maxWinsError, setMaxWinsError] = React.useState(null);
      const [gameMode, setGameMode] = React.useState("5x5");
      const [lastWinnerCourtA, setLastWinnerCourtA] = React.useState(null);
      const [swappingPlayer, setSwappingPlayer] = React.useState(null);
      const [swapError, setSwapError] = React.useState(null);
      const [pendingWinner, setPendingWinner] = React.useState(null);
      const [pendingStart, setPendingStart] = React.useState(null);

      const lastFillState = React.useRef({ waitlistLength: 0, nextTeamLength: 0, gameMode: "5x5" });

      // Generate unique ID
      const generateId = () => `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;

      // Memoized getPlayerName
      const getPlayerName = React.useCallback((id) => {
        const player = players.find(p => p.id === id);
        if (!player) {
          console.warn(`getPlayerName: No player found for ID ${id}`);
          return "";
        }
        return player.name;
      }, [players]);

      // Debounce function for localStorage
      const debounce = (func, wait) => {
        let timeout;
        return (...args) => {
          clearTimeout(timeout);
          timeout = setTimeout(() => func(...args), wait);
        };
      };

      // getTeamSize before useEffect
      const getTeamSize = React.useCallback(() => {
        switch (gameMode) {
          case "5x5": return 5;
          case "4x4": return 4;
          case "3x3": return 3;
          default: return 5;
        }
      }, [gameMode]);

      // Load initial state
      React.useEffect(() => {
        try {
          const savedState = localStorage.getItem("bballManagerState");
          if (savedState) {
            const state = JSON.parse(savedState);
            setPlayers(state.players || []);
            setWaitlist(state.waitlist || []);
            setPausedList(state.pausedList || []);
            setNextTeam(state.nextTeam || []);
            setTeam1(state.team1 || []);
            setTeam2(state.team2 || []);
            setTeam3(state.team3 || []);
            setTeam4(state.team4 || []);
            setTeam1Wins(state.team1Wins || 0);
            setTeam3Wins(state.team3Wins || 0);
            setGameStartedA(state.gameStartedA || false);
            setGameStartedB(state.gameStartedB || false);
            setTeam1Label(state.team1Label || "Team 1");
            setTeam2Label(state.team2Label || "Team 2");
            setTeam3Label(state.team3Label || "Team 3");
            setTeam4Label(state.team4Label || "Team 4");
            setMaxWinsLimit(state.maxWinsLimit || 5);
            setGameMode(state.gameMode || "5x5");
            setLastWinnerCourtA(state.lastWinnerCourtA || null);
          }
          setLoading(false);
        } catch (err) {
          setError("Failed to load data. Please refresh.");
          setLoading(false);
        }
      }, []);

      // Save state to localStorage with debounce
      React.useEffect(() => {
        const saveState = debounce(() => {
          try {
            const state = { players, waitlist, pausedList, nextTeam, team1, team2, team3, team4, team1Wins, team3Wins, gameStartedA, gameStartedB, team1Label, team2Label, team3Label, team4Label, maxWinsLimit, gameMode, lastWinnerCourtA };
            localStorage.setItem("bballManagerState", JSON.stringify(state));
            console.log("Saved state to localStorage:", { nextTeam: nextTeam.map(getPlayerName), waitlist: waitlist.map(getPlayerName) });
            if (window.performance && performance.memory) {
              console.log("Memory usage:", performance.memory.usedJSHeapSize / 1024 / 1024, "MB");
            }
          } catch (err) {
            setError("Failed to save data to localStorage. Check storage settings.");
            console.error(err);
          }
        }, 500);

        saveState();
        return () => clearTimeout(saveState);
      }, [players, waitlist, pausedList, nextTeam, team1, team2, team3, team4, team1Wins, team3Wins, gameStartedA, gameStartedB, team1Label, team2Label, team3Label, team4Label, maxWinsLimit, gameMode, lastWinnerCourtA, getPlayerName]);

      // Simplified fillNextTeam
      const fillNextTeam = React.useCallback(() => {
        if (gameMode === "3x3") {
          console.log(`fillNextTeam: ${gameMode} mode not implemented yet.`);
          return;
        }
        const teamSize = getTeamSize();
        console.log("fillNextTeam: Starting - Waitlist:", waitlist.map(getPlayerName), 
                    "NextTeam:", nextTeam.map(getPlayerName), 
                    "TeamSize:", teamSize);
        let newNextTeam = [...nextTeam];
        let newWaitlist = [...waitlist];
        if (newNextTeam.length < teamSize) {
          while (newNextTeam.length < teamSize && newWaitlist.length > 0) {
            const playerId = newWaitlist[0];
            if (players.find(p => p.id === playerId) && !newNextTeam.includes(playerId)) {
              newNextTeam.push(playerId);
              newWaitlist.shift();
              console.log("fillNextTeam: Added player", getPlayerName(playerId), "to nextTeam");
            } else {
              console.warn("fillNextTeam: Skipping invalid or duplicate player ID:", playerId);
              newWaitlist.shift();
            }
          }
          setNextTeam(newNextTeam);
          setWaitlist(newWaitlist);
        }
        console.log("fillNextTeam: Completed - Waitlist:", newWaitlist.map(getPlayerName), 
                    "NextTeam:", newNextTeam.map(getPlayerName));
      }, [players, waitlist, nextTeam, gameMode, getPlayerName, getTeamSize]);

      // fillNextTeam useEffect
      React.useEffect(() => {
        const teamSize = getTeamSize();
        const currentState = { waitlistLength: waitlist.length, nextTeamLength: nextTeam.length, gameMode };
        if (
          currentState.waitlistLength === lastFillState.current.waitlistLength &&
          currentState.nextTeamLength === lastFillState.current.nextTeamLength &&
          currentState.gameMode === lastFillState.current.gameMode &&
          nextTeam.length >= teamSize
        ) {
          console.log("useEffect: Skipping fillNextTeam - state unchanged or team full.", 
                      "NextTeam:", nextTeam.map(getPlayerName), 
                      "Waitlist:", waitlist.map(getPlayerName));
          return;
        }
        console.log("useEffect: Triggering fillNextTeam - Waitlist:", waitlist.map(getPlayerName), 
                    "NextTeam:", nextTeam.map(getPlayerName));
        fillNextTeam();
        lastFillState.current = currentState;
        return () => {
          console.log("Cleaning up fillNextTeam useEffect");
        };
      }, [waitlist, gameMode, nextTeam, getPlayerName, fillNextTeam, getTeamSize]);

      const totalCount = players.length;

      React.useEffect(() => {
        if (totalCount < 16 && totalCount >= 10 && gameMode === "4x4") {
          setGameMode("5x5");
          setTeam3([]);
          setTeam4([]);
          setTeam3Wins(0);
          setGameStartedB(false);
          setTeam3Label("Team 3");
          setTeam4Label("Team 4");
          setLastWinnerCourtA(null);
          console.log("Auto-switched to 5x5 mode due to insufficient players (< 16).");
        }
      }, [totalCount, gameMode]);

      const addPlayer = React.useCallback(() => {
        console.log("addPlayer called with name:", playerName);
        const name = playerName.trim();
        if (!name) {
          setSignupError("Please enter a valid name.");
          console.log("addPlayer: Empty name entered.");
          return;
        }
        if (name.length > 15) {
          setSignupError("Player name must be 15 characters or less.");
          console.log("addPlayer: Name too long:", name);
          return;
        }
        const normalizedName = name.toLowerCase().trim();
        const isDuplicate = players.some(p => p.name.toLowerCase().trim() === normalizedName);
        console.log("addPlayer: Duplicate check for", name, "result:", isDuplicate);
        if (isDuplicate) {
          setSignupError("Player name already exists.");
          return;
        }
        const newPlayer = { id: generateId(), name, wins: 0, losses: 0, winStreak: 0 };
        setPlayers(prev => [...prev, newPlayer]);
        setWaitlist(prev => [...prev, newPlayer.id]);
        setPlayerName("");
        setSignupError(null);
        console.log("addPlayer: Added player", name, "ID:", newPlayer.id, 
                    "New Waitlist:", [...waitlist, newPlayer.id].map(getPlayerName));
      }, [playerName, players, waitlist, getPlayerName]);

      const pausePlayer = React.useCallback((id) => {
        console.log("pausePlayer called for player ID:", id, "Name:", getPlayerName(id));
        setWaitlist(prev => prev.filter(pid => pid !== id));
        setPausedList(prev => [...prev, id]);
      }, [getPlayerName]);

      const readyPlayer = React.useCallback((id) => {
        console.log("readyPlayer called for player ID:", id, "Name:", getPlayerName(id));
        setPausedList(prev => prev.filter(pid => pid !== id));
        setWaitlist(prev => [...prev, id]);
      }, [getPlayerName]);

      const removePlayer = React.useCallback((id) => {
        console.log("removePlayer called for player ID:", id, "Name:", getPlayerName(id));
        setPlayers(prev => prev.filter(p => p.id !== id));
        setWaitlist(prev => prev.filter(pid => pid !== id));
        setPausedList(prev => prev.filter(pid => pid !== id));
        setNextTeam(prev => prev.filter(pid => pid !== id));
        setTeam1(prev => prev.filter(pid => pid !== id));
        setTeam2(prev => prev.filter(pid => pid !== id));
        setTeam3(prev => prev.filter(pid => pid !== id));
        setTeam4(prev => prev.filter(pid => pid !== id));
        console.log("removePlayer: After removal - Waitlist:", waitlist.filter(pid => pid !== id).map(getPlayerName), 
                    "NextTeam:", nextTeam.filter(pid => pid !== id).map(getPlayerName));
      }, [waitlist, nextTeam, getPlayerName]);

      const startSwap = React.useCallback((id, sourceList) => {
        console.log("startSwap called for player ID:", id, "Name:", getPlayerName(id), 
                    "SourceList:", sourceList, 
                    "Waitlist:", waitlist.map(getPlayerName));
        if (waitlist.length === 0) {
          setSwapError("No players available on Waitlist to swap.");
          console.log("startSwap: Aborted - Waitlist empty.");
          return;
        }
        setSwappingPlayer({ id, sourceList });
        setSwapError(null);
      }, [waitlist, getPlayerName]);

      const completeSwap = React.useCallback((waitlistPlayerId) => {
        if (!swappingPlayer || !waitlist.includes(waitlistPlayerId)) {
          setSwapError("Invalid player selection for swap.");
          console.warn("completeSwap: Invalid player IDs - SwappingPlayer:", swappingPlayer, "Waitlist:", waitlist);
          setSwappingPlayer(null);
          return;
        }
        const { id: sourcePlayerId, sourceList } = swappingPlayer;
        console.log("completeSwap called. Swapping player ID:", sourcePlayerId, "Name:", getPlayerName(sourcePlayerId), 
                    "from", sourceList, 
                    "with Waitlist player ID:", waitlistPlayerId, "Name:", getPlayerName(waitlistPlayerId));

        let isValid = false;
        switch (sourceList) {
          case "waitlist": isValid = waitlist.includes(sourcePlayerId); break;
          case "pausedList": isValid = pausedList.includes(sourcePlayerId); break;
          case "nextTeam": isValid = nextTeam.includes(sourcePlayerId); break;
          case "team1": isValid = team1.includes(sourcePlayerId); break;
          case "team2": isValid = team2.includes(sourcePlayerId); break;
          case "team3": isValid = team3.includes(sourcePlayerId); break;
          case "team4": isValid = team4.includes(sourcePlayerId); break;
          default: console.warn("completeSwap: Invalid sourceList:", sourceList);
        }
        if (!isValid) {
          setSwapError("Source player not found in specified list.");
          console.warn("completeSwap: Source player ID", sourcePlayerId, "not in", sourceList);
          setSwappingPlayer(null);
          return;
        }

        switch (sourceList) {
          case "waitlist":
            setWaitlist(prev => prev.map(id => id === sourcePlayerId ? waitlistPlayerId : id === waitlistPlayerId ? sourcePlayerId : id));
            break;
          case "pausedList":
            setPausedList(prev => prev.filter(id => id !== sourcePlayerId).concat(waitlistPlayerId));
            setWaitlist(prev => prev.filter(id => id !== waitlistPlayerId).concat(sourcePlayerId));
            break;
          case "nextTeam":
            setNextTeam(prev => prev.filter(id => id !== sourcePlayerId).concat(waitlistPlayerId));
            setWaitlist(prev => prev.filter(id => id !== waitlistPlayerId).concat(sourcePlayerId));
            break;
          case "team1":
            setTeam1(prev => prev.filter(id => id !== sourcePlayerId).concat(waitlistPlayerId));
            setWaitlist(prev => prev.filter(id => id !== waitlistPlayerId).concat(sourcePlayerId));
            break;
          case "team2":
            setTeam2(prev => prev.filter(id => id !== sourcePlayerId).concat(waitlistPlayerId));
            setWaitlist(prev => prev.filter(id => id !== waitlistPlayerId).concat(sourcePlayerId));
            break;
          case "team3":
            setTeam3(prev => prev.filter(id => id !== sourcePlayerId).concat(waitlistPlayerId));
            setWaitlist(prev => prev.filter(id => id !== waitlistPlayerId).concat(sourcePlayerId));
            break;
          case "team4":
            setTeam4(prev => prev.filter(id => id !== sourcePlayerId).concat(waitlistPlayerId));
            setWaitlist(prev => prev.filter(id => id !== waitlistPlayerId).concat(sourcePlayerId));
            break;
        }

        console.log("completeSwap: Swap completed - Updated lists:", {
          waitlist: waitlist.map(getPlayerName),
          pausedList: pausedList.map(getPlayerName),
          nextTeam: nextTeam.map(getPlayerName),
          team1: team1.map(getPlayerName),
          team2: team2.map(getPlayerName),
          team3: team3.map(getPlayerName),
          team4: team4.map(getPlayerName),
        });
        setSwappingPlayer(null);
        setSwapError(null);
      }, [swappingPlayer, waitlist, pausedList, nextTeam, team1, team2, team3, team4, getPlayerName]);

      const cancelSwap = React.useCallback(() => {
        console.log("cancelSwap called. Clearing swappingPlayer:", swappingPlayer);
        setSwappingPlayer(null);
        setSwapError(null);
      }, [swappingPlayer]);

      const shuffleArray = (array) => {
        const shuffled = [...array];
        for (let i = shuffled.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
        }
        return shuffled;
      };

      const startFirstGame = React.useCallback((court) => {
        if (gameMode === "3x3") {
          alert(`${gameMode} mode not implemented yet.`);
          return;
        }
        const teamSize = getTeamSize();
        const minPlayers = gameMode === "5x5" ? teamSize * 2 : teamSize * 2;
        if (totalCount < minPlayers) {
          alert(`Need at least ${minPlayers} players for ${gameMode} mode on ${court}.`);
          return;
        }
        if (nextTeam.length < teamSize || waitlist.length < teamSize) {
          alert(`Need at least ${teamSize} players on Next Team and ${teamSize} on Waitlist for ${court}.`);
          return;
        }
        console.log(`startFirstGame ${court}: Initial - NextTeam:`, nextTeam.map(getPlayerName), 
                    "Waitlist:", waitlist.map(getPlayerName));

        if (gameMode === "4x4" && court === "A" && !gameStartedA && !gameStartedB) {
          const minPlayersBothCourts = teamSize * 4;
          if (totalCount >= minPlayersBothCourts) {
            setGameStartedA(true);
            setGameStartedB(true);
            const newTeam1 = nextTeam.slice(0, teamSize);
            const remainingNextTeam = nextTeam.slice(teamSize);
            let newWaitlist = [...waitlist];
            const newTeam2 = newWaitlist.slice(0, teamSize);
            newWaitlist = newWaitlist.slice(teamSize);
            const newTeam3 = remainingNextTeam.length >= teamSize ? remainingNextTeam.slice(0, teamSize) : [...remainingNextTeam, ...newWaitlist.slice(0, teamSize - remainingNextTeam.length)];
            newWaitlist = newWaitlist.slice(teamSize - remainingNextTeam.length);
            const newTeam4 = newWaitlist.slice(0, teamSize);
            newWaitlist = newWaitlist.slice(teamSize);

            console.log("4x4-Fresh Both Courts: Team1:", newTeam1.map(getPlayerName), 
                        "Team2:", newTeam2.map(getPlayerName), 
                        "Team3:", newTeam3.map(getPlayerName), 
                        "Team4:", newTeam4.map(getPlayerName), 
                        "Waitlist:", newWaitlist.map(getPlayerName));

            setTeam1(newTeam1);
            setTeam2(newTeam2);
            setTeam3(newTeam3);
            setTeam4(newTeam4);
            setWaitlist(newWaitlist);
            setNextTeam([]);
            setTeam1Label("Team 1");
            setTeam2Label("Team 2");
            setTeam3Label("Team 3");
            setTeam4Label("Team 4");
          } else {
            setGameStartedA(true);
            const newTeam1 = nextTeam.slice(0, teamSize);
            const newTeam2 = waitlist.slice(0, teamSize);
            const newWaitlist = waitlist.slice(teamSize);

            console.log("4x4-Fresh Court A: Team1:", newTeam1.map(getPlayerName), 
                        "Team2:", newTeam2.map(getPlayerName), 
                        "Waitlist:", newWaitlist.map(getPlayerName));

            setTeam1(newTeam1);
            setTeam2(newTeam2);
            setWaitlist(newWaitlist);
            setNextTeam([]);
            setTeam1Label("Team 1");
            setTeam2Label("Team 2");
          }
        } else if (gameMode === "5x5" && court === "A") {
          setGameStartedA(true);
          const newTeam1 = nextTeam.slice(0, teamSize);
          const newTeam2 = waitlist.slice(0, teamSize);
          const newWaitlist = waitlist.slice(teamSize);

          console.log("5x5-Fresh Court A: Team1:", newTeam1.map(getPlayerName), 
                      "Team2:", newTeam2.map(getPlayerName), 
                      "Waitlist:", newWaitlist.map(getPlayerName), 
                      "NextTeam cleared");

          setTeam1(newTeam1);
          setTeam2(newTeam2);
          setWaitlist(newWaitlist);
          setNextTeam([]);
          setTeam1Label("Team 1");
          setTeam2Label("Team 2");
        } else if (gameMode === "4x4" && court === "B" && !gameStartedB && totalCount >= teamSize * 4) {
          setGameStartedB(true);
          const newTeam3 = nextTeam.slice(0, teamSize);
          const newTeam4 = waitlist.slice(0, teamSize);
          const newWaitlist = waitlist.slice(teamSize);

          console.log("4x4-Fresh Court B: Team3:", newTeam3.map(getPlayerName), 
                      "Team4:", newTeam4.map(getPlayerName), 
                      "Waitlist:", newWaitlist.map(getPlayerName));

          setTeam3(newTeam3);
          setTeam4(newTeam4);
          setWaitlist(newWaitlist);
          setNextTeam([]);
          setTeam1Label("Team 1");
          setTeam2Label("Team 2");
          setTeam3Label("Team 3");
          setTeam4Label("Team 4");
        } else {
          alert(`Cannot start game on ${court}. Check game mode and active games.`);
        }
      }, [gameMode, totalCount, nextTeam, waitlist, getTeamSize, getPlayerName]);

      const startNextGame = React.useCallback((court) => {
        if (gameMode === "3x3") {
          alert(`${gameMode} mode not implemented yet.`);
          return;
        }
        const teamSize = getTeamSize();
        const minPlayers = gameMode === "5x5" ? teamSize * 2 : teamSize * 4;
        if (totalCount < minPlayers) {
          alert(`Need at least ${minPlayers} players for ${gameMode} mode.`);
          return;
        }
        if (nextTeam.length < teamSize) {
          alert(`Not enough players in Next Team (need ${teamSize}) for ${court}.`);
          return;
        }
        console.log(`startNextGame ${court}: NextTeam:`, nextTeam.map(getPlayerName), 
                    "Waitlist:", waitlist.map(getPlayerName));
        if (court === "A") {
          setTeam2(nextTeam.slice(0, teamSize));
          setNextTeam([]);
          setTeam2Label("Team 2 (Challengers)");
          setTeam1Label("Team 1 (Winners)");
          console.log("startNextGame Court A: Team2:", nextTeam.slice(0, teamSize).map(getPlayerName), 
                      "NextTeam cleared");
        } else if (court === "B") {
          setTeam4(nextTeam.slice(0, teamSize));
          setNextTeam([]);
          setTeam4Label("Team 4 (Challengers)");
          setTeam3Label("Team 3 (Winners)");
          console.log("startNextGame Court B: Team4:", nextTeam.slice(0, teamSize).map(getPlayerName), 
                      "NextTeam cleared");
        }
      }, [gameMode, totalCount, nextTeam, waitlist, getTeamSize, getPlayerName]);

      const initiateStartNextGame = React.useCallback((court) => {
        console.log(`initiateStartNextGame called for Court: ${court}`);
        setPendingStart(court);
      }, []);

      const confirmStartNextGame = React.useCallback(() => {
        if (!pendingStart) {
          console.warn("confirmStartNextGame: No pending start to confirm.");
          return;
        }
        console.log(`confirmStartNextGame: Confirmed start for Court: ${pendingStart}`);
        startNextGame(pendingStart);
        setPendingStart(null);
      }, [pendingStart, startNextGame]);

      const cancelStartNextGame = React.useCallback(() => {
        console.log("cancelStartNextGame called. Clearing pendingStart:", pendingStart);
        setPendingStart(null);
      }, [pendingStart]);

      const initiateWinnerConfirmation = React.useCallback((court, winner) => {
        console.log(`initiateWinnerConfirmation called for Court: ${court}, Winner: ${winner}`);
        setPendingWinner({ court, winner });
      }, []);

      const confirmWinner = React.useCallback(() => {
        if (!pendingWinner) {
          console.warn("confirmWinner: No pending winner to confirm.");
          return;
        }
        const { court, winner } = pendingWinner;
        console.log(`confirmWinner: Confirmed winner for Court: ${court}, Winner: ${winner}`);
        declareWinner(court, winner);
        setPendingWinner(null);
      }, [pendingWinner]);

      const cancelWinnerConfirmation = React.useCallback(() => {
        console.log("cancelWinnerConfirmation called. Clearing pendingWinner:", pendingWinner);
        setPendingWinner(null);
      }, [pendingWinner]);

      const declareWinner = React.useCallback((court, winner) => {
        if (gameMode === "3x3") {
          alert(`${gameMode} mode not implemented yet.`);
          return;
        }
        const teamSize = getTeamSize();
        console.log(`declareWinner ${court} ${winner}: Waitlist:`, waitlist.map(getPlayerName), 
                    "NextTeam:", nextTeam.map(getPlayerName));
        let winners, losers, newTeam1, newTeam3, newTeam1Wins, newTeam3Wins, newTeam1Label, newTeam2Label, newTeam3Label, newTeam4Label;

        if (court === "A") {
          if (winner === "Team 1") {
            winners = team1;
            losers = team2;
            newTeam1 = team1;
            newTeam1Wins = team1Wins + 1;
            newTeam1Label = "Team 1 (Winners)";
            newTeam2Label = "Team 2";
          } else {
            winners = team2;
            losers = team1;
            newTeam1 = team2;
            newTeam1Wins = 1;
            newTeam1Label = "Team 1 (Winners)";
            newTeam2Label = "Team 2";
          }
          setLastWinnerCourtA(winners);
        } else if (court === "B") {
          if (winner === "Team 3") {
            winners = team3;
            losers = team4;
            newTeam3 = team3;
            newTeam3Wins = team3Wins + 1;
            newTeam3Label = "Team 3 (Winners)";
            newTeam4Label = "Team 4";
          } else {
            winners = team4;
            losers = team3;
            newTeam3 = team4;
            newTeam3Wins = 1;
            newTeam3Label = "Team 3 (Winners)";
            newTeam4Label = "Team 4";
          }
        }

        setPlayers(prev => prev.map(p => {
          if (winners.includes(p.id)) {
            return { ...p, wins: p.wins + 1, winStreak: p.winStreak + 1 };
          }
          if (losers.includes(p.id)) {
            return { ...p, losses: p.losses + 1, winStreak: 0 };
          }
          return p;
        }));

        let newWaitlist = [...waitlist];
        console.log("declareWinner: Initial waitlist:", newWaitlist.map(getPlayerName));

        if ((court === "A" && newTeam1Wins >= maxWinsLimit) || (court === "B" && newTeam3Wins >= maxWinsLimit)) {
          console.log("Max-out triggered on", court, "Initial Waitlist:", newWaitlist.map(getPlayerName), 
                      "NextTeam:", nextTeam.map(getPlayerName));
          if (court === "A") {
            newWaitlist = [...newWaitlist, ...newTeam1];
            console.log("Max-out Court A Step 1: Added Team 1 to waitlist:", newWaitlist.map(getPlayerName));
            setTeam1([]);
            console.log("Max-out Court A Step 2: Cleared Team 1");
            newWaitlist = [...newWaitlist, ...losers];
            console.log("Max-out Court A Step 3: Added Team 2 to waitlist:", newWaitlist.map(getPlayerName));
            setTeam2([]);
            console.log("Max-out Court A Step 4: Cleared Team 2");
            let newTeam1Players = [];
            let newTeam2Players = [];
            if (nextTeam.length >= teamSize) {
              newTeam1Players = nextTeam.slice(0, teamSize);
              console.log("Max-out Court A Step 5: Moved nextTeam to Team 1:", newTeam1Players.map(getPlayerName));
              setTeam1(newTeam1Players);
              setNextTeam(nextTeam.slice(teamSize));
              setTeam1Label("Team 1 (Winners)");
            } else {
              console.log("Max-out Court A Step 5: Insufficient players in nextTeam to form Team 1:", nextTeam.map(getPlayerName));
              alert("Not enough players in Next Team to form Team 1 after max-out on Court A.");
            }
            newWaitlist = shuffleArray(newWaitlist);
            setWaitlist(newWaitlist);
            setTeam2(newTeam2Players);
            setTeam1Wins(0);
            setTeam1Label(newTeam1Players.length > 0 ? "Team 1 (Winners)" : "Team 1");
            setTeam2Label("Team 2");
            setLastWinnerCourtA(null);
            console.log("Max-out Court A Final: Team1:", newTeam1Players.map(getPlayerName), 
                        "Team2:", newTeam2Players.map(getPlayerName), 
                        "Waitlist:", newWaitlist.map(getPlayerName), 
                        "NextTeam:", nextTeam.slice(teamSize).map(getPlayerName));
          } else if (court === "B") {
            newWaitlist = [...newWaitlist, ...newTeam3];
            console.log("Max-out Court B Step 1: Added Team 3 to waitlist:", newWaitlist.map(getPlayerName));
            setTeam3([]);
            console.log("Max-out Court B Step 2: Cleared Team 3");
            newWaitlist = [...newWaitlist, ...losers];
            console.log("Max-out Court B Step 3: Added Team 4 to waitlist:", newWaitlist.map(getPlayerName));
            setTeam4([]);
            console.log("Max-out Court B Step 4: Cleared Team 4");
            let newTeam3Players = [];
            let newTeam4Players = [];
            if (nextTeam.length >= teamSize) {
              newTeam3Players = nextTeam.slice(0, teamSize);
              console.log("Max-out Court B Step 5: Moved nextTeam to Team 3:", newTeam3Players.map(getPlayerName));
              setTeam3(newTeam3Players);
              setNextTeam(nextTeam.slice(teamSize));
              setTeam3Label("Team 3 (Winners)");
            } else {
              console.log("Max-out Court B Step 5: Insufficient players in nextTeam to form Team 3:", nextTeam.map(getPlayerName));
              alert("Not enough players in Next Team to form Team 3 after max-out on Court B.");
            }
            newWaitlist = shuffleArray(newWaitlist);
            setWaitlist(newWaitlist);
            setTeam4(newTeam4Players);
            setTeam3Wins(0);
            setTeam3Label(newTeam3Players.length > 0 ? "Team 3 (Winners)" : "Team 3");
            setTeam4Label("Team 4");
            console.log("Max-out Court B Final: Team3:", newTeam3Players.map(getPlayerName), 
                        "Team4:", newTeam4Players.map(getPlayerName), 
                        "Waitlist:", newWaitlist.map(getPlayerName), 
                        "NextTeam:", nextTeam.slice(teamSize).map(getPlayerName));
          }
        } else {
          if (court === "A") {
            setTeam1(newTeam1);
            setTeam2([]);
            setWaitlist([...newWaitlist, ...losers]);
            setTeam1Wins(newTeam1Wins);
            setTeam1Label(newTeam1Label);
            setTeam2Label(newTeam2Label);
          } else if (court === "B") {
            setTeam3(newTeam3);
            setTeam4([]);
            setWaitlist([...newWaitlist, ...losers]);
            setTeam3Wins(newTeam3Wins);
            setTeam3Label(newTeam3Label);
            setTeam4Label(newTeam4Label);
          }
          console.log("declareWinner: Non-max-out - Waitlist:", [...newWaitlist, ...losers].map(getPlayerName), 
                      "NextTeam:", nextTeam.map(getPlayerName));
        }
      }, [gameMode, maxWinsLimit, team1, team2, team3, team4, team1Wins, team3Wins, waitlist, nextTeam, players, getTeamSize, getPlayerName]);

      const setMaxWins = React.useCallback(() => {
        const value = parseInt(maxWinsInput, 10);
        if (isNaN(value) || value <= 0) {
          setMaxWinsError("Please enter a positive number.");
          return;
        }
        setMaxWinsLimit(value);
        setMaxWinsInput("");
        setMaxWinsError(null);
        console.log("Max wins limit set to:", value);
      }, [maxWinsInput]);

      const handleGameModeChange = React.useCallback((e) => {
        const newMode = e.target.value;
        const teamSize = newMode === "5x5" ? 5 : 4;
        const minPlayers = newMode === "5x5" ? 10 : 8;
        const minPlayersBothCourts = newMode === "4x4" ? 16 : 10;

        if (newMode === "3x3") {
          alert("3x3 mode not implemented yet.");
          return;
        }

        if (totalCount < minPlayers) {
          alert(`Need at least ${minPlayers} players for ${newMode} mode.`);
          return;
        }

        if (newMode === "4x4" && gameMode === "5x5" && gameStartedA && lastWinnerCourtA && totalCount >= minPlayersBothCourts) {
          console.log("4x4-Split: Winners:", lastWinnerCourtA.map(getPlayerName));
          const winners = shuffleArray([...lastWinnerCourtA]);
          const team1Winners = winners.slice(0, 3);
          const team3Winners = winners.slice(3, 5);
          let remainingNextTeam = [...nextTeam];
          let newWaitlist = [...waitlist];

          let newTeam1 = [...team1Winners];
          if (remainingNextTeam.length >= 1) {
            newTeam1.push(remainingNextTeam.shift());
          } else if (newWaitlist.length >= 1) {
            newTeam1.push(newWaitlist.shift());
          } else {
            alert("Not enough players to form Team 1 in 4x4-Split.");
            return;
          }

          let newTeam3 = [...team3Winners];
          if (remainingNextTeam.length >= 2) {
            newTeam3.push(...remainingNextTeam.splice(0, 2));
          } else if (remainingNextTeam.length === 1 && newWaitlist.length >= 1) {
            newTeam3.push(remainingNextTeam.shift(), newWaitlist.shift());
          } else if (newWaitlist.length >= 2) {
            newTeam3.push(...newWaitlist.splice(0, 2));
          } else {
            alert("Not enough players to form Team 3 in 4x4-Split.");
            return;
          }

          let newTeam2 = [];
          const team2Slots = 4;
          if (remainingNextTeam.length >= team2Slots) {
            newTeam2 = remainingNextTeam.splice(0, team2Slots);
          } else {
            newTeam2 = [...remainingNextTeam, ...newWaitlist.splice(0, team2Slots - remainingNextTeam.length)];
            remainingNextTeam = [];
          }

          let newTeam4 = [];
          if (newWaitlist.length >= 4) {
            newTeam4 = newWaitlist.splice(0, 4);
          } else {
            alert("Not enough players to form Team 4 in 4x4-Split.");
            return;
          }

          console.log("4x4-Split: Team1:", newTeam1.map(getPlayerName), 
                      "Team2:", newTeam2.map(getPlayerName), 
                      "Team3:", newTeam3.map(getPlayerName), 
                      "Team4:", newTeam4.map(getPlayerName), 
                      "Waitlist:", newWaitlist.map(getPlayerName));

          setGameMode(newMode);
          setGameStartedA(true);
          setGameStartedB(true);
          setTeam1(newTeam1);
          setTeam2(newTeam2);
          setTeam3(newTeam3);
          setTeam4(newTeam4);
          setWaitlist(newWaitlist);
          setNextTeam([]);
          setTeam1Wins(0);
          setTeam3Wins(0);
          setTeam1Label("Team 1");
          setTeam2Label("Team 2");
          setTeam3Label("Team 3");
          setTeam4Label("Team 4");
          setLastWinnerCourtA(null);
        } else if (newMode === "4x4" && (!gameStartedA && !gameStartedB && totalCount >= minPlayers)) {
          setGameMode(newMode);
          console.log("Game mode changed to 4x4-Fresh.");
        } else if (newMode === "5x5") {
          setGameMode(newMode);
          setTeam3([]);
          setTeam4([]);
          setTeam3Wins(0);
          setGameStartedB(false);
          setTeam3Label("Team 3");
          setTeam4Label("Team 4");
          setLastWinnerCourtA(null);
          console.log("Game mode changed to 5x5.");
        } else {
          alert(`Cannot switch to ${newMode} mode. Ensure sufficient players or no conflicting games.`);
        }
      }, [gameMode, totalCount, gameStartedA, gameStartedB, lastWinnerCourtA, nextTeam, waitlist, players, getPlayerName]);

      const clearAll = React.useCallback(() => {
        setPlayers([]);
        setWaitlist([]);
        setPausedList([]);
        setNextTeam([]);
        setTeam1([]);
        setTeam2([]);
        setTeam3([]);
        setTeam4([]);
        setTeam1Wins(0);
        setTeam3Wins(0);
        setGameStartedA(false);
        setGameStartedB(false);
        setTeam1Label("Team 1");
        setTeam2Label("Team 2");
        setTeam3Label("Team 3");
        setTeam4Label("Team 4");
        setError(null);
        setSignupError(null);
        setMaxWinsLimit(5);
        setMaxWinsInput("");
        setMaxWinsError(null);
        setGameMode("5x5");
        setLastWinnerCourtA(null);
        setSwappingPlayer(null);
        setSwapError(null);
        setPendingWinner(null);
        setPendingStart(null);
      }, []);

      const clearScores = React.useCallback(() => {
        setPlayers(prev => prev.map(p => ({ ...p, wins: 0, losses: 0, winStreak: 0 })));
      }, []);

      const maxWins = Math.max(...players.map(p => p.wins), 0);
      const waitlistCount = new Set([...waitlist]).size;
      const pausedCount = pausedList.length;

      if (loading) {
        return React.createElement("div", { className: "text-center text-xl" }, "Loading...");
      }

      if (error) {
        return React.createElement("div", { className: "text-center text-red-500" },
          React.createElement("p", null, error),
          React.createElement("button", {
            onClick: () => window.location.reload(),
            className: "mt-2 bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700"
          }, "Try Again")
        );
      }

      return React.createElement("div", { className: "space-y-6" },
        React.createElement("h1", { className: "text-3xl font-bold text-center" }, "RFCN BBALL Game Manager"),
        React.createElement("div", { className: "flex justify-around bg-white p-4 rounded shadow" },
          React.createElement("p", { className: "font-semibold" }, `Total #: ${totalCount}`),
          React.createElement("p", { className: "font-semibold" }, `Waitlist #: ${waitlistCount}`),
          React.createElement("p", { className: "font-semibold" }, `Paused #: ${pausedCount}`)
        ),
        React.createElement("div", { className: "bg-white p-4 rounded shadow" },
          React.createElement("h2", { className: "text-xl font-semibold mb-2" }, "Player Signup"),
          React.createElement("div", { className: "flex flex-col space-y-2" },
            React.createElement("div", { className: "flex space-x-2" },
              React.createElement("input", {
                type: "text",
                value: playerName,
                onChange: (e) => { setPlayerName(e.target.value); setSignupError(null); },
                placeholder: "Enter player name (max 15 chars)",
                maxLength: 15,
                className: "flex-1 p-2 border rounded-lg"
              }),
              React.createElement("button", {
                onClick: addPlayer,
                className: "bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700"
              }, "Sign Up")
            ),
            signupError && React.createElement("p", { className: "text-red-500 text-sm" }, signupError)
          )
        ),
        React.createElement("div", { className: "grid grid-cols-1 md:grid-cols-3 gap-4" },
          React.createElement("div", { className: "bg-white p-4 rounded shadow" },
            React.createElement("h2", { className: "text-xl font-semibold mb-2" }, "Waitlist"),
            React.createElement("ul", { className: "space-y-2" },
              waitlist.map(id => React.createElement("li", { key: id, className: "flex justify-between items-center" },
                React.createElement("p", null, getPlayerName(id)),
                React.createElement("div", { className: "space-x-2" },
                  React.createElement("button", { 
                    onClick: () => startSwap(id, "waitlist"), 
                    disabled: waitlist.length <= 1,
                    className: "bg-purple-600 text-white px-2 py-1 rounded-lg hover:bg-purple-700 disabled:bg-gray-400"
                  }, "Swap"),
                  React.createElement("button", { 
                    onClick: () => pausePlayer(id), 
                    className: "bg-yellow-500 text-white px-2 py-1 rounded-lg hover:bg-yellow-600" 
                  }, "Pause"),
                  React.createElement("button", { 
                    onClick: () => removePlayer(id), 
                    className: "bg-red-600 text-white px-2 py-1 rounded-lg hover:bg-red-700" 
                  }, "Remove")
                )
              ))
            )
          ),
          React.createElement("div", { className: "bg-white p-4 rounded shadow" },
            React.createElement("h2", { className: "text-xl font-semibold mb-2" }, "Paused List"),
            React.createElement("ul", { className: "space-y-2" },
              pausedList.map(id => React.createElement("li", { key: id, className: "flex justify-between items-center" },
                React.createElement("p", null, getPlayerName(id)),
                React.createElement("div", { className: "space-x-2" },
                  React.createElement("button", { 
                    onClick: () => startSwap(id, "pausedList"), 
                    disabled: waitlist.length === 0,
                    className: "bg-purple-600 text-white px-2 py-1 rounded-lg hover:bg-purple-700 disabled:bg-gray-400"
                  }, "Swap"),
                  React.createElement("button", { 
                    onClick: () => readyPlayer(id), 
                    className: "bg-green-600 text-white px-2 py-1 rounded-lg hover:bg-green-700" 
                  }, "Ready")
                )
              ))
            )
          ),
          React.createElement("div", { className: "bg-white p-4 rounded shadow" },
            React.createElement("h2", { className: "text-xl font-semibold mb-2" }, "Next Team"),
            React.createElement("ul", { className: "space-y-2" },
              nextTeam.map(id => React.createElement("li", { key: id, className: "flex justify-between items-center" },
                React.createElement("p", null, getPlayerName(id)),
                React.createElement("button", { 
                  onClick: () => startSwap(id, "nextTeam"), 
                  disabled: waitlist.length === 0,
                  className: "bg-purple-600 text-white px-2 py-1 rounded-lg hover:bg-purple-700 disabled:bg-gray-400"
                }, "Swap")
              ))
            )
          ),
          swappingPlayer && React.createElement("div", { className: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center" },
            React.createElement("div", { className: "bg-white p-6 rounded-lg shadow-lg max-w-md w-full" },
              React.createElement("h3", { className: "text-lg font-semibold mb-4" }, 
                `Select Waitlist Player to Swap with ${getPlayerName(swappingPlayer.id)}`),
              React.createElement("ul", { className: "space-y-2 mb-4" },
                waitlist.filter(id => id !== swappingPlayer.id).map(id => 
                  React.createElement("li", { key: id, className: "flex justify-between items-center" },
                    React.createElement("p", null, getPlayerName(id)),
                    React.createElement("button", {
                      onClick: () => completeSwap(id),
                      className: "bg-blue-600 text-white px-2 py-1 rounded-lg hover:bg-blue-700"
                    }, "Select")
                  )
                )
              ),
              swapError && React.createElement("p", { className: "text-red-500 text-sm mb-4" }, swapError),
              React.createElement("button", {
                onClick: cancelSwap,
                className: "bg-gray-500 text-white px-4 py-2 rounded-lg hover:bg-gray-600"
              }, "Cancel")
            )
          ),
          pendingWinner && React.createElement("div", { className: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center" },
            React.createElement("div", { className: "bg-white p-6 rounded-lg shadow-lg max-w-md w-full" },
              React.createElement("h3", { className: "text-lg font-semibold mb-4" }, 
                `Are you sure you want to select ${pendingWinner.winner === "Team 1" ? team1Label : 
                                                  pendingWinner.winner === "Team 2" ? team2Label : 
                                                  pendingWinner.winner === "Team 3" ? team3Label : team4Label} ` +
                `(Players: ${(pendingWinner.winner === "Team 1" ? team1 : 
                              pendingWinner.winner === "Team 2" ? team2 : 
                              pendingWinner.winner === "Team 3" ? team3 : team4)
                              .map(getPlayerName)
                              .join(", ") || "None"}) as the winner of Court ${pendingWinner.court}?`),
              React.createElement("div", { className: "flex justify-end space-x-4" },
                React.createElement("button", {
                  onClick: confirmWinner,
                  className: "bg-green-600 text-white px-4 py-2 rounded-lg hover:bg-green-700"
                }, "Confirm"),
                React.createElement("button", {
                  onClick: cancelWinnerConfirmation,
                  className: "bg-gray-500 text-white px-4 py-2 rounded-lg hover:bg-gray-600"
                }, "Cancel")
              )
            )
          ),
          pendingStart && React.createElement("div", { className: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center" },
            React.createElement("div", { className: "bg-white p-6 rounded-lg shadow-lg max-w-md w-full" },
              React.createElement("h3", { className: "text-lg font-semibold mb-4" }, 
                `Are you sure you want to start the next game on Court ${pendingStart}, placing ` +
                `${pendingStart === "A" ? team2Label : team4Label} ` +
                `(Players: ${nextTeam.map(getPlayerName).join(", ") || "None"}) from the Next Team?`),
              React.createElement("p", { className: "text-sm mb-4" }, 
                `Current winning team: ${pendingStart === "A" ? team1Label : team3Label} ` +
                `with a win streak of ${pendingStart === "A" ? team1Wins : team3Wins}.`),
              (pendingStart === "A" && team1Wins === maxWinsLimit - 1 || 
               pendingStart === "B" && team3Wins === maxWinsLimit - 1) && 
                React.createElement("p", { className: "text-sm text-red-500 mb-4" }, 
                  "This is the last game for the current winning team."),
              React.createElement("div", { className: "flex justify-end space-x-4" },
                React.createElement("button", {
                  onClick: confirmStartNextGame,
                  className: "bg-green-600 text-white px-4 py-2 rounded-lg hover:bg-green-700"
                }, "Confirm"),
                React.createElement("button", {
                  onClick: cancelStartNextGame,
                  className: "bg-gray-500 text-white px-4 py-2 rounded-lg hover:bg-gray-600"
                }, "Cancel")
              )
            )
          )
        ),
        React.createElement("div", { className: "bg-white p-4 rounded shadow" },
          React.createElement("h2", { className: "text-xl font-semibold mb-2" }, "How We Play Around Here"),
          React.createElement("ul", { className: "list-disc list-inside space-y-2" },
            React.createElement("li", null, "Love God, Love Others, Be Grateful!"),
            React.createElement("li", null, "Respect Each Other; Respect the Call."),
            React.createElement("li", null, "Minimum Age: 16")
          )
        ),
        React.createElement("div", { className: "grid grid-cols-1 md:grid-cols-2 gap-4" },
          React.createElement("div", { className: "space-y-6" },
            React.createElement("div", { className: "bg-white p-4 rounded shadow" },
              React.createElement("h2", { className: "text-xl font-semibold mb-2" }, "Court A"),
              React.createElement("div", { className: "grid grid-cols-1 md:grid-cols-2 gap-4" },
                React.createElement("div", null,
                  React.createElement("h3", { className: "text-lg font-semibold mb-2" }, team1Label),
                  React.createElement("ul", { className: "space-y-2" },
                    team1.map(id => React.createElement("li", { key: id, className: "flex justify-between items-center" },
                      React.createElement("p", null, getPlayerName(id)),
                      React.createElement("button", { 
                        onClick: () => startSwap(id, "team1"), 
                        disabled: waitlist.length === 0,
                        className: "bg-purple-600 text-white px-2 py-1 rounded-lg hover:bg-purple-700 disabled:bg-gray-400"
                      }, "Swap")
                    ))
                  ),
                  gameStartedA && team2.length > 0 && React.createElement("button", {
                    onClick: () => initiateWinnerConfirmation("A", "Team 1"),
                    className: "mt-2 w-full bg-green-600 text-white px-4 py-2 rounded-lg hover:bg-green-700",
                    disabled: pendingWinner !== null || pendingStart !== null
                  }, `${team1Label} Wins`)
                ),
                React.createElement("div", null,
                  React.createElement("h3", { className: "text-lg font-semibold mb-2" }, team2Label),
                  React.createElement("ul", { className: "space-y-2" },
                    team2.map(id => React.createElement("li", { key: id, className: "flex justify-between items-center" },
                      React.createElement("p", null, getPlayerName(id)),
                      React.createElement("button", { 
                        onClick: () => startSwap(id, "team2"), 
                        disabled: waitlist.length === 0,
                        className: "bg-purple-600 text-white px-2 py-1 rounded-lg hover:bg-purple-700 disabled:bg-gray-400"
                      }, "Swap")
                    ))
                  ),
                  gameStartedA && team2.length > 0 && React.createElement("button", {
                    onClick: () => initiateWinnerConfirmation("A", "Team 2"),
                    className: "mt-2 w-full bg-green-600 text-white px-4 py-2 rounded-lg hover:bg-green-700",
                    disabled: pendingWinner !== null || pendingStart !== null
                  }, `${team2Label} Wins`)
                )
              ),
              React.createElement("div", { className: "flex justify-center space-x-4 mt-4" },
                React.createElement("button", {
                  onClick: () => startFirstGame("A"),
                  disabled: gameStartedA || totalCount < (gameMode === "5x5" ? 10 : 8) || pendingWinner !== null || pendingStart !== null,
                  className: "bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 disabled:bg-gray-400"
                }, "Start First Game: Court A"),
                React.createElement("button", {
                  onClick: () => initiateStartNextGame("A"),
                  disabled: totalCount < (gameMode === "5x5" ? 10 : 8) || team2.length > 0 || pendingWinner !== null || pendingStart !== null,
                  className: "bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 disabled:bg-gray-400"
                }, "Start Next Game: Court A")
              )
            ),
            gameMode === "4x4" && React.createElement("div", { className: "bg-white p-4 rounded shadow" },
              React.createElement("h2", { className: "text-xl font-semibold mb-2" }, "Court B"),
              React.createElement("div", { className: "grid grid-cols-1 md:grid-cols-2 gap-4" },
                React.createElement("div", null,
                  React.createElement("h3", { className: "text-lg font-semibold mb-2" }, team3Label),
                  React.createElement("ul", { className: "space-y-2" },
                    team3.map(id => React.createElement("li", { key: id, className: "flex justify-between items-center" },
                      React.createElement("p", null, getPlayerName(id)),
                      React.createElement("button", { 
                        onClick: () => startSwap(id, "team3"), 
                        disabled: waitlist.length === 0,
                        className: "bg-purple-600 text-white px-2 py-1 rounded-lg hover:bg-purple-700 disabled:bg-gray-400"
                      }, "Swap")
                    ))
                  ),
                  gameStartedB && team4.length > 0 && React.createElement("button", {
                    onClick: () => initiateWinnerConfirmation("B", "Team 3"),
                    className: "mt-2 w-full bg-green-600 text-white px-4 py-2 rounded-lg hover:bg-green-700",
                    disabled: pendingWinner !== null || pendingStart !== null
                  }, `${team3Label} Wins`)
                ),
                React.createElement("div", null,
                  React.createElement("h3", { className: "text-lg font-semibold mb-2" }, team4Label),
                  React.createElement("ul", { className: "space-y-2" },
                    team4.map(id => React.createElement("li", { key: id, className: "flex justify-between items-center" },
                      React.createElement("p", null, getPlayerName(id)),
                      React.createElement("button", { 
                        onClick: () => startSwap(id, "team4"), 
                        disabled: waitlist.length === 0,
                        className: "bg-purple-600 text-white px-2 py-1 rounded-lg hover:bg-purple-700 disabled:bg-gray-400"
                      }, "Swap")
                    ))
                  ),
                  gameStartedB && team4.length > 0 && React.createElement("button", {
                    onClick: () => initiateWinnerConfirmation("B", "Team 4"),
                    className: "mt-2 w-full bg-green-600 text-white px-4 py-2 rounded-lg hover:bg-green-700",
                    disabled: pendingWinner !== null || pendingStart !== null
                  }, `${team4Label} Wins`)
                )
              ),
              React.createElement("div", { className: "flex justify-center space-x-4 mt-4" },
                React.createElement("button", {
                  onClick: () => startFirstGame("B"),
                  disabled: gameStartedB || totalCount < 16 || pendingWinner !== null || pendingStart !== null,
                  className: "bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 disabled:bg-gray-400"
                }, "Start First Game: Court B"),
                React.createElement("button", {
                  onClick: () => initiateStartNextGame("B"),
                  disabled: totalCount < 16 || team4.length > 0 || pendingWinner !== null || pendingStart !== null,
                  className: "bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 disabled:bg-gray-400"
                }, "Start Next Game: Court B")
              )
            )
          ),
          React.createElement("div", { className: "space-y-6" },
            React.createElement("div", { className: "flex flex-col items-center space-y-4" },
              React.createElement("div", { className: "flex justify-center space-x-4" },
                React.createElement("button", { 
                  onClick: clearAll, 
                  className: "bg-red-700 text-white px-4 py-2 rounded-lg hover:bg-red-800" 
                }, "Clear All")
              ),
              React.createElement("div", { className: "bg-white p-4 rounded shadow w-full max-w-md" },
                React.createElement("h3", { className: "text-lg font-semibold mb-2" }, `Game Mode: ${gameMode}`),
                React.createElement("div", { className: "flex space-x-2" },
                  React.createElement("select", {
                    value: gameMode,
                    onChange: handleGameModeChange,
                    className: "flex-1 p-2 border rounded-lg"
                  },
                    React.createElement("option", { value: "5x5" }, "5x5"),
                    React.createElement("option", { value: "4x4" }, "4x4"),
                    React.createElement("option", { value: "3x3" }, "3x3")
                  )
                )
              ),
              React.createElement("div", { className: "bg-white p-4 rounded shadow w-full max-w-md" },
                React.createElement("h3", { className: "text-lg font-semibold mb-2" }, `Max Wins Limit: ${maxWinsLimit}`),
                React.createElement("div", { className: "flex flex-col space-y-2" },
                  React.createElement("div", { className: "flex space-x-2" },
                    React.createElement("input", {
                      type: "number",
                      value: maxWinsInput,
                      onChange: (e) => { setMaxWinsInput(e.target.value); setMaxWinsError(null); },
                      placeholder: "Enter max wins",
                      className: "flex-1 p-2 border rounded-lg"
                    }),
                    React.createElement("button", {
                      onClick: setMaxWins,
                      className: "bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700"
                    }, "Set")
                  ),
                  maxWinsError && React.createElement("p", { className: "text-red-500 text-sm" }, maxWinsError)
                )
              )
            ),
            React.createElement("div", { className: "bg-white p-4 rounded shadow" },
              React.createElement("h2", { className: "text-xl font-semibold mb-2" }, "Scoreboard"),
              React.createElement("table", { className: "w-full text-center" },
                React.createElement("thead", null,
                  React.createElement("tr", { className: "bg-gray-200" },
                    React.createElement("th", { className: "p-2" }, "Name"),
                    React.createElement("th", { className: "p-2" }, "Wins"),
                    React.createElement("th", { className: "p-2" }, "Win Streak"),
                    React.createElement("th", { className: "p-2" }, "Losses")
                  )
                ),
                React.createElement("tbody", null,
                  players.sort((a, b) => a.name.toLowerCase().localeCompare(b.name.toLowerCase())).map(p => 
                    React.createElement("tr", {
                      key: p.id,
                      className: p.wins === maxWins && maxWins > 0 ? "bg-yellow-200" : ""
                    },
                      React.createElement("td", { className: "p-2" }, p.name),
                      React.createElement("td", { className: "p-2" }, p.wins),
                      React.createElement("td", { className: "p-2" }, p.winStreak),
                      React.createElement("td", { className: "p-2" }, p.losses)
                    )
                  )
                )
              ),
              React.createElement("button", { 
                onClick: clearScores, 
                className: "mt-2 bg-red-700 text-white px-4 py-2 rounded-lg hover:bg-red-800" 
              }, "Clear All Scores")
            )
          )
        )
      );
    });

    const root = ReactDOM.createRoot(document.getElementById("root"));
    root.render(React.createElement(App));
  </script>
</body>
</html>
